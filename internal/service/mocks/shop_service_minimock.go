// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/merynayr/AvitoShop/internal/service.ShopService -o shop_service_minimock.go -n ShopServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ShopServiceMock implements mm_service.ShopService
type ShopServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetMerchPrice          func(ctx context.Context, item string) (i1 int64, err error)
	funcGetMerchPriceOrigin    string
	inspectFuncGetMerchPrice   func(ctx context.Context, item string)
	afterGetMerchPriceCounter  uint64
	beforeGetMerchPriceCounter uint64
	GetMerchPriceMock          mShopServiceMockGetMerchPrice
}

// NewShopServiceMock returns a mock for mm_service.ShopService
func NewShopServiceMock(t minimock.Tester) *ShopServiceMock {
	m := &ShopServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetMerchPriceMock = mShopServiceMockGetMerchPrice{mock: m}
	m.GetMerchPriceMock.callArgs = []*ShopServiceMockGetMerchPriceParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mShopServiceMockGetMerchPrice struct {
	optional           bool
	mock               *ShopServiceMock
	defaultExpectation *ShopServiceMockGetMerchPriceExpectation
	expectations       []*ShopServiceMockGetMerchPriceExpectation

	callArgs []*ShopServiceMockGetMerchPriceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ShopServiceMockGetMerchPriceExpectation specifies expectation struct of the ShopService.GetMerchPrice
type ShopServiceMockGetMerchPriceExpectation struct {
	mock               *ShopServiceMock
	params             *ShopServiceMockGetMerchPriceParams
	paramPtrs          *ShopServiceMockGetMerchPriceParamPtrs
	expectationOrigins ShopServiceMockGetMerchPriceExpectationOrigins
	results            *ShopServiceMockGetMerchPriceResults
	returnOrigin       string
	Counter            uint64
}

// ShopServiceMockGetMerchPriceParams contains parameters of the ShopService.GetMerchPrice
type ShopServiceMockGetMerchPriceParams struct {
	ctx  context.Context
	item string
}

// ShopServiceMockGetMerchPriceParamPtrs contains pointers to parameters of the ShopService.GetMerchPrice
type ShopServiceMockGetMerchPriceParamPtrs struct {
	ctx  *context.Context
	item *string
}

// ShopServiceMockGetMerchPriceResults contains results of the ShopService.GetMerchPrice
type ShopServiceMockGetMerchPriceResults struct {
	i1  int64
	err error
}

// ShopServiceMockGetMerchPriceOrigins contains origins of expectations of the ShopService.GetMerchPrice
type ShopServiceMockGetMerchPriceExpectationOrigins struct {
	origin     string
	originCtx  string
	originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetMerchPrice *mShopServiceMockGetMerchPrice) Optional() *mShopServiceMockGetMerchPrice {
	mmGetMerchPrice.optional = true
	return mmGetMerchPrice
}

// Expect sets up expected params for ShopService.GetMerchPrice
func (mmGetMerchPrice *mShopServiceMockGetMerchPrice) Expect(ctx context.Context, item string) *mShopServiceMockGetMerchPrice {
	if mmGetMerchPrice.mock.funcGetMerchPrice != nil {
		mmGetMerchPrice.mock.t.Fatalf("ShopServiceMock.GetMerchPrice mock is already set by Set")
	}

	if mmGetMerchPrice.defaultExpectation == nil {
		mmGetMerchPrice.defaultExpectation = &ShopServiceMockGetMerchPriceExpectation{}
	}

	if mmGetMerchPrice.defaultExpectation.paramPtrs != nil {
		mmGetMerchPrice.mock.t.Fatalf("ShopServiceMock.GetMerchPrice mock is already set by ExpectParams functions")
	}

	mmGetMerchPrice.defaultExpectation.params = &ShopServiceMockGetMerchPriceParams{ctx, item}
	mmGetMerchPrice.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetMerchPrice.expectations {
		if minimock.Equal(e.params, mmGetMerchPrice.defaultExpectation.params) {
			mmGetMerchPrice.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetMerchPrice.defaultExpectation.params)
		}
	}

	return mmGetMerchPrice
}

// ExpectCtxParam1 sets up expected param ctx for ShopService.GetMerchPrice
func (mmGetMerchPrice *mShopServiceMockGetMerchPrice) ExpectCtxParam1(ctx context.Context) *mShopServiceMockGetMerchPrice {
	if mmGetMerchPrice.mock.funcGetMerchPrice != nil {
		mmGetMerchPrice.mock.t.Fatalf("ShopServiceMock.GetMerchPrice mock is already set by Set")
	}

	if mmGetMerchPrice.defaultExpectation == nil {
		mmGetMerchPrice.defaultExpectation = &ShopServiceMockGetMerchPriceExpectation{}
	}

	if mmGetMerchPrice.defaultExpectation.params != nil {
		mmGetMerchPrice.mock.t.Fatalf("ShopServiceMock.GetMerchPrice mock is already set by Expect")
	}

	if mmGetMerchPrice.defaultExpectation.paramPtrs == nil {
		mmGetMerchPrice.defaultExpectation.paramPtrs = &ShopServiceMockGetMerchPriceParamPtrs{}
	}
	mmGetMerchPrice.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetMerchPrice.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetMerchPrice
}

// ExpectItemParam2 sets up expected param item for ShopService.GetMerchPrice
func (mmGetMerchPrice *mShopServiceMockGetMerchPrice) ExpectItemParam2(item string) *mShopServiceMockGetMerchPrice {
	if mmGetMerchPrice.mock.funcGetMerchPrice != nil {
		mmGetMerchPrice.mock.t.Fatalf("ShopServiceMock.GetMerchPrice mock is already set by Set")
	}

	if mmGetMerchPrice.defaultExpectation == nil {
		mmGetMerchPrice.defaultExpectation = &ShopServiceMockGetMerchPriceExpectation{}
	}

	if mmGetMerchPrice.defaultExpectation.params != nil {
		mmGetMerchPrice.mock.t.Fatalf("ShopServiceMock.GetMerchPrice mock is already set by Expect")
	}

	if mmGetMerchPrice.defaultExpectation.paramPtrs == nil {
		mmGetMerchPrice.defaultExpectation.paramPtrs = &ShopServiceMockGetMerchPriceParamPtrs{}
	}
	mmGetMerchPrice.defaultExpectation.paramPtrs.item = &item
	mmGetMerchPrice.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmGetMerchPrice
}

// Inspect accepts an inspector function that has same arguments as the ShopService.GetMerchPrice
func (mmGetMerchPrice *mShopServiceMockGetMerchPrice) Inspect(f func(ctx context.Context, item string)) *mShopServiceMockGetMerchPrice {
	if mmGetMerchPrice.mock.inspectFuncGetMerchPrice != nil {
		mmGetMerchPrice.mock.t.Fatalf("Inspect function is already set for ShopServiceMock.GetMerchPrice")
	}

	mmGetMerchPrice.mock.inspectFuncGetMerchPrice = f

	return mmGetMerchPrice
}

// Return sets up results that will be returned by ShopService.GetMerchPrice
func (mmGetMerchPrice *mShopServiceMockGetMerchPrice) Return(i1 int64, err error) *ShopServiceMock {
	if mmGetMerchPrice.mock.funcGetMerchPrice != nil {
		mmGetMerchPrice.mock.t.Fatalf("ShopServiceMock.GetMerchPrice mock is already set by Set")
	}

	if mmGetMerchPrice.defaultExpectation == nil {
		mmGetMerchPrice.defaultExpectation = &ShopServiceMockGetMerchPriceExpectation{mock: mmGetMerchPrice.mock}
	}
	mmGetMerchPrice.defaultExpectation.results = &ShopServiceMockGetMerchPriceResults{i1, err}
	mmGetMerchPrice.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetMerchPrice.mock
}

// Set uses given function f to mock the ShopService.GetMerchPrice method
func (mmGetMerchPrice *mShopServiceMockGetMerchPrice) Set(f func(ctx context.Context, item string) (i1 int64, err error)) *ShopServiceMock {
	if mmGetMerchPrice.defaultExpectation != nil {
		mmGetMerchPrice.mock.t.Fatalf("Default expectation is already set for the ShopService.GetMerchPrice method")
	}

	if len(mmGetMerchPrice.expectations) > 0 {
		mmGetMerchPrice.mock.t.Fatalf("Some expectations are already set for the ShopService.GetMerchPrice method")
	}

	mmGetMerchPrice.mock.funcGetMerchPrice = f
	mmGetMerchPrice.mock.funcGetMerchPriceOrigin = minimock.CallerInfo(1)
	return mmGetMerchPrice.mock
}

// When sets expectation for the ShopService.GetMerchPrice which will trigger the result defined by the following
// Then helper
func (mmGetMerchPrice *mShopServiceMockGetMerchPrice) When(ctx context.Context, item string) *ShopServiceMockGetMerchPriceExpectation {
	if mmGetMerchPrice.mock.funcGetMerchPrice != nil {
		mmGetMerchPrice.mock.t.Fatalf("ShopServiceMock.GetMerchPrice mock is already set by Set")
	}

	expectation := &ShopServiceMockGetMerchPriceExpectation{
		mock:               mmGetMerchPrice.mock,
		params:             &ShopServiceMockGetMerchPriceParams{ctx, item},
		expectationOrigins: ShopServiceMockGetMerchPriceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetMerchPrice.expectations = append(mmGetMerchPrice.expectations, expectation)
	return expectation
}

// Then sets up ShopService.GetMerchPrice return parameters for the expectation previously defined by the When method
func (e *ShopServiceMockGetMerchPriceExpectation) Then(i1 int64, err error) *ShopServiceMock {
	e.results = &ShopServiceMockGetMerchPriceResults{i1, err}
	return e.mock
}

// Times sets number of times ShopService.GetMerchPrice should be invoked
func (mmGetMerchPrice *mShopServiceMockGetMerchPrice) Times(n uint64) *mShopServiceMockGetMerchPrice {
	if n == 0 {
		mmGetMerchPrice.mock.t.Fatalf("Times of ShopServiceMock.GetMerchPrice mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetMerchPrice.expectedInvocations, n)
	mmGetMerchPrice.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetMerchPrice
}

func (mmGetMerchPrice *mShopServiceMockGetMerchPrice) invocationsDone() bool {
	if len(mmGetMerchPrice.expectations) == 0 && mmGetMerchPrice.defaultExpectation == nil && mmGetMerchPrice.mock.funcGetMerchPrice == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetMerchPrice.mock.afterGetMerchPriceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetMerchPrice.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetMerchPrice implements mm_service.ShopService
func (mmGetMerchPrice *ShopServiceMock) GetMerchPrice(ctx context.Context, item string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetMerchPrice.beforeGetMerchPriceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetMerchPrice.afterGetMerchPriceCounter, 1)

	mmGetMerchPrice.t.Helper()

	if mmGetMerchPrice.inspectFuncGetMerchPrice != nil {
		mmGetMerchPrice.inspectFuncGetMerchPrice(ctx, item)
	}

	mm_params := ShopServiceMockGetMerchPriceParams{ctx, item}

	// Record call args
	mmGetMerchPrice.GetMerchPriceMock.mutex.Lock()
	mmGetMerchPrice.GetMerchPriceMock.callArgs = append(mmGetMerchPrice.GetMerchPriceMock.callArgs, &mm_params)
	mmGetMerchPrice.GetMerchPriceMock.mutex.Unlock()

	for _, e := range mmGetMerchPrice.GetMerchPriceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetMerchPrice.GetMerchPriceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMerchPrice.GetMerchPriceMock.defaultExpectation.Counter, 1)
		mm_want := mmGetMerchPrice.GetMerchPriceMock.defaultExpectation.params
		mm_want_ptrs := mmGetMerchPrice.GetMerchPriceMock.defaultExpectation.paramPtrs

		mm_got := ShopServiceMockGetMerchPriceParams{ctx, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetMerchPrice.t.Errorf("ShopServiceMock.GetMerchPrice got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetMerchPrice.GetMerchPriceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmGetMerchPrice.t.Errorf("ShopServiceMock.GetMerchPrice got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetMerchPrice.GetMerchPriceMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetMerchPrice.t.Errorf("ShopServiceMock.GetMerchPrice got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetMerchPrice.GetMerchPriceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetMerchPrice.GetMerchPriceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetMerchPrice.t.Fatal("No results are set for the ShopServiceMock.GetMerchPrice")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetMerchPrice.funcGetMerchPrice != nil {
		return mmGetMerchPrice.funcGetMerchPrice(ctx, item)
	}
	mmGetMerchPrice.t.Fatalf("Unexpected call to ShopServiceMock.GetMerchPrice. %v %v", ctx, item)
	return
}

// GetMerchPriceAfterCounter returns a count of finished ShopServiceMock.GetMerchPrice invocations
func (mmGetMerchPrice *ShopServiceMock) GetMerchPriceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMerchPrice.afterGetMerchPriceCounter)
}

// GetMerchPriceBeforeCounter returns a count of ShopServiceMock.GetMerchPrice invocations
func (mmGetMerchPrice *ShopServiceMock) GetMerchPriceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMerchPrice.beforeGetMerchPriceCounter)
}

// Calls returns a list of arguments used in each call to ShopServiceMock.GetMerchPrice.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetMerchPrice *mShopServiceMockGetMerchPrice) Calls() []*ShopServiceMockGetMerchPriceParams {
	mmGetMerchPrice.mutex.RLock()

	argCopy := make([]*ShopServiceMockGetMerchPriceParams, len(mmGetMerchPrice.callArgs))
	copy(argCopy, mmGetMerchPrice.callArgs)

	mmGetMerchPrice.mutex.RUnlock()

	return argCopy
}

// MinimockGetMerchPriceDone returns true if the count of the GetMerchPrice invocations corresponds
// the number of defined expectations
func (m *ShopServiceMock) MinimockGetMerchPriceDone() bool {
	if m.GetMerchPriceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMerchPriceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMerchPriceMock.invocationsDone()
}

// MinimockGetMerchPriceInspect logs each unmet expectation
func (m *ShopServiceMock) MinimockGetMerchPriceInspect() {
	for _, e := range m.GetMerchPriceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ShopServiceMock.GetMerchPrice at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetMerchPriceCounter := mm_atomic.LoadUint64(&m.afterGetMerchPriceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMerchPriceMock.defaultExpectation != nil && afterGetMerchPriceCounter < 1 {
		if m.GetMerchPriceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ShopServiceMock.GetMerchPrice at\n%s", m.GetMerchPriceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ShopServiceMock.GetMerchPrice at\n%s with params: %#v", m.GetMerchPriceMock.defaultExpectation.expectationOrigins.origin, *m.GetMerchPriceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMerchPrice != nil && afterGetMerchPriceCounter < 1 {
		m.t.Errorf("Expected call to ShopServiceMock.GetMerchPrice at\n%s", m.funcGetMerchPriceOrigin)
	}

	if !m.GetMerchPriceMock.invocationsDone() && afterGetMerchPriceCounter > 0 {
		m.t.Errorf("Expected %d calls to ShopServiceMock.GetMerchPrice at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMerchPriceMock.expectedInvocations), m.GetMerchPriceMock.expectedInvocationsOrigin, afterGetMerchPriceCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ShopServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetMerchPriceInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ShopServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ShopServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetMerchPriceDone()
}
