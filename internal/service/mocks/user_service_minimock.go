// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/merynayr/AvitoShop/internal/service.UserService -o user_service_minimock.go -n UserServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/merynayr/AvitoShop/internal/model"
)

// UserServiceMock implements mm_service.UserService
type UserServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBuy          func(ctx context.Context, user *model.User, item string) (err error)
	funcBuyOrigin    string
	inspectFuncBuy   func(ctx context.Context, user *model.User, item string)
	afterBuyCounter  uint64
	beforeBuyCounter uint64
	BuyMock          mUserServiceMockBuy

	funcGetUserByName          func(ctx context.Context, name string) (up1 *model.User, err error)
	funcGetUserByNameOrigin    string
	inspectFuncGetUserByName   func(ctx context.Context, name string)
	afterGetUserByNameCounter  uint64
	beforeGetUserByNameCounter uint64
	GetUserByNameMock          mUserServiceMockGetUserByName

	funcGetUserInfo          func(ctx context.Context, userID int64) (i1 model.InfoResponse, err error)
	funcGetUserInfoOrigin    string
	inspectFuncGetUserInfo   func(ctx context.Context, userID int64)
	afterGetUserInfoCounter  uint64
	beforeGetUserInfoCounter uint64
	GetUserInfoMock          mUserServiceMockGetUserInfo

	funcSendCoins          func(ctx context.Context, userID int64, SendCoins model.SendCoinRequest) (err error)
	funcSendCoinsOrigin    string
	inspectFuncSendCoins   func(ctx context.Context, userID int64, SendCoins model.SendCoinRequest)
	afterSendCoinsCounter  uint64
	beforeSendCoinsCounter uint64
	SendCoinsMock          mUserServiceMockSendCoins
}

// NewUserServiceMock returns a mock for mm_service.UserService
func NewUserServiceMock(t minimock.Tester) *UserServiceMock {
	m := &UserServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BuyMock = mUserServiceMockBuy{mock: m}
	m.BuyMock.callArgs = []*UserServiceMockBuyParams{}

	m.GetUserByNameMock = mUserServiceMockGetUserByName{mock: m}
	m.GetUserByNameMock.callArgs = []*UserServiceMockGetUserByNameParams{}

	m.GetUserInfoMock = mUserServiceMockGetUserInfo{mock: m}
	m.GetUserInfoMock.callArgs = []*UserServiceMockGetUserInfoParams{}

	m.SendCoinsMock = mUserServiceMockSendCoins{mock: m}
	m.SendCoinsMock.callArgs = []*UserServiceMockSendCoinsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserServiceMockBuy struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockBuyExpectation
	expectations       []*UserServiceMockBuyExpectation

	callArgs []*UserServiceMockBuyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserServiceMockBuyExpectation specifies expectation struct of the UserService.Buy
type UserServiceMockBuyExpectation struct {
	mock               *UserServiceMock
	params             *UserServiceMockBuyParams
	paramPtrs          *UserServiceMockBuyParamPtrs
	expectationOrigins UserServiceMockBuyExpectationOrigins
	results            *UserServiceMockBuyResults
	returnOrigin       string
	Counter            uint64
}

// UserServiceMockBuyParams contains parameters of the UserService.Buy
type UserServiceMockBuyParams struct {
	ctx  context.Context
	user *model.User
	item string
}

// UserServiceMockBuyParamPtrs contains pointers to parameters of the UserService.Buy
type UserServiceMockBuyParamPtrs struct {
	ctx  *context.Context
	user **model.User
	item *string
}

// UserServiceMockBuyResults contains results of the UserService.Buy
type UserServiceMockBuyResults struct {
	err error
}

// UserServiceMockBuyOrigins contains origins of expectations of the UserService.Buy
type UserServiceMockBuyExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
	originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBuy *mUserServiceMockBuy) Optional() *mUserServiceMockBuy {
	mmBuy.optional = true
	return mmBuy
}

// Expect sets up expected params for UserService.Buy
func (mmBuy *mUserServiceMockBuy) Expect(ctx context.Context, user *model.User, item string) *mUserServiceMockBuy {
	if mmBuy.mock.funcBuy != nil {
		mmBuy.mock.t.Fatalf("UserServiceMock.Buy mock is already set by Set")
	}

	if mmBuy.defaultExpectation == nil {
		mmBuy.defaultExpectation = &UserServiceMockBuyExpectation{}
	}

	if mmBuy.defaultExpectation.paramPtrs != nil {
		mmBuy.mock.t.Fatalf("UserServiceMock.Buy mock is already set by ExpectParams functions")
	}

	mmBuy.defaultExpectation.params = &UserServiceMockBuyParams{ctx, user, item}
	mmBuy.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmBuy.expectations {
		if minimock.Equal(e.params, mmBuy.defaultExpectation.params) {
			mmBuy.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBuy.defaultExpectation.params)
		}
	}

	return mmBuy
}

// ExpectCtxParam1 sets up expected param ctx for UserService.Buy
func (mmBuy *mUserServiceMockBuy) ExpectCtxParam1(ctx context.Context) *mUserServiceMockBuy {
	if mmBuy.mock.funcBuy != nil {
		mmBuy.mock.t.Fatalf("UserServiceMock.Buy mock is already set by Set")
	}

	if mmBuy.defaultExpectation == nil {
		mmBuy.defaultExpectation = &UserServiceMockBuyExpectation{}
	}

	if mmBuy.defaultExpectation.params != nil {
		mmBuy.mock.t.Fatalf("UserServiceMock.Buy mock is already set by Expect")
	}

	if mmBuy.defaultExpectation.paramPtrs == nil {
		mmBuy.defaultExpectation.paramPtrs = &UserServiceMockBuyParamPtrs{}
	}
	mmBuy.defaultExpectation.paramPtrs.ctx = &ctx
	mmBuy.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmBuy
}

// ExpectUserParam2 sets up expected param user for UserService.Buy
func (mmBuy *mUserServiceMockBuy) ExpectUserParam2(user *model.User) *mUserServiceMockBuy {
	if mmBuy.mock.funcBuy != nil {
		mmBuy.mock.t.Fatalf("UserServiceMock.Buy mock is already set by Set")
	}

	if mmBuy.defaultExpectation == nil {
		mmBuy.defaultExpectation = &UserServiceMockBuyExpectation{}
	}

	if mmBuy.defaultExpectation.params != nil {
		mmBuy.mock.t.Fatalf("UserServiceMock.Buy mock is already set by Expect")
	}

	if mmBuy.defaultExpectation.paramPtrs == nil {
		mmBuy.defaultExpectation.paramPtrs = &UserServiceMockBuyParamPtrs{}
	}
	mmBuy.defaultExpectation.paramPtrs.user = &user
	mmBuy.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmBuy
}

// ExpectItemParam3 sets up expected param item for UserService.Buy
func (mmBuy *mUserServiceMockBuy) ExpectItemParam3(item string) *mUserServiceMockBuy {
	if mmBuy.mock.funcBuy != nil {
		mmBuy.mock.t.Fatalf("UserServiceMock.Buy mock is already set by Set")
	}

	if mmBuy.defaultExpectation == nil {
		mmBuy.defaultExpectation = &UserServiceMockBuyExpectation{}
	}

	if mmBuy.defaultExpectation.params != nil {
		mmBuy.mock.t.Fatalf("UserServiceMock.Buy mock is already set by Expect")
	}

	if mmBuy.defaultExpectation.paramPtrs == nil {
		mmBuy.defaultExpectation.paramPtrs = &UserServiceMockBuyParamPtrs{}
	}
	mmBuy.defaultExpectation.paramPtrs.item = &item
	mmBuy.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmBuy
}

// Inspect accepts an inspector function that has same arguments as the UserService.Buy
func (mmBuy *mUserServiceMockBuy) Inspect(f func(ctx context.Context, user *model.User, item string)) *mUserServiceMockBuy {
	if mmBuy.mock.inspectFuncBuy != nil {
		mmBuy.mock.t.Fatalf("Inspect function is already set for UserServiceMock.Buy")
	}

	mmBuy.mock.inspectFuncBuy = f

	return mmBuy
}

// Return sets up results that will be returned by UserService.Buy
func (mmBuy *mUserServiceMockBuy) Return(err error) *UserServiceMock {
	if mmBuy.mock.funcBuy != nil {
		mmBuy.mock.t.Fatalf("UserServiceMock.Buy mock is already set by Set")
	}

	if mmBuy.defaultExpectation == nil {
		mmBuy.defaultExpectation = &UserServiceMockBuyExpectation{mock: mmBuy.mock}
	}
	mmBuy.defaultExpectation.results = &UserServiceMockBuyResults{err}
	mmBuy.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmBuy.mock
}

// Set uses given function f to mock the UserService.Buy method
func (mmBuy *mUserServiceMockBuy) Set(f func(ctx context.Context, user *model.User, item string) (err error)) *UserServiceMock {
	if mmBuy.defaultExpectation != nil {
		mmBuy.mock.t.Fatalf("Default expectation is already set for the UserService.Buy method")
	}

	if len(mmBuy.expectations) > 0 {
		mmBuy.mock.t.Fatalf("Some expectations are already set for the UserService.Buy method")
	}

	mmBuy.mock.funcBuy = f
	mmBuy.mock.funcBuyOrigin = minimock.CallerInfo(1)
	return mmBuy.mock
}

// When sets expectation for the UserService.Buy which will trigger the result defined by the following
// Then helper
func (mmBuy *mUserServiceMockBuy) When(ctx context.Context, user *model.User, item string) *UserServiceMockBuyExpectation {
	if mmBuy.mock.funcBuy != nil {
		mmBuy.mock.t.Fatalf("UserServiceMock.Buy mock is already set by Set")
	}

	expectation := &UserServiceMockBuyExpectation{
		mock:               mmBuy.mock,
		params:             &UserServiceMockBuyParams{ctx, user, item},
		expectationOrigins: UserServiceMockBuyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmBuy.expectations = append(mmBuy.expectations, expectation)
	return expectation
}

// Then sets up UserService.Buy return parameters for the expectation previously defined by the When method
func (e *UserServiceMockBuyExpectation) Then(err error) *UserServiceMock {
	e.results = &UserServiceMockBuyResults{err}
	return e.mock
}

// Times sets number of times UserService.Buy should be invoked
func (mmBuy *mUserServiceMockBuy) Times(n uint64) *mUserServiceMockBuy {
	if n == 0 {
		mmBuy.mock.t.Fatalf("Times of UserServiceMock.Buy mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBuy.expectedInvocations, n)
	mmBuy.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmBuy
}

func (mmBuy *mUserServiceMockBuy) invocationsDone() bool {
	if len(mmBuy.expectations) == 0 && mmBuy.defaultExpectation == nil && mmBuy.mock.funcBuy == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBuy.mock.afterBuyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBuy.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Buy implements mm_service.UserService
func (mmBuy *UserServiceMock) Buy(ctx context.Context, user *model.User, item string) (err error) {
	mm_atomic.AddUint64(&mmBuy.beforeBuyCounter, 1)
	defer mm_atomic.AddUint64(&mmBuy.afterBuyCounter, 1)

	mmBuy.t.Helper()

	if mmBuy.inspectFuncBuy != nil {
		mmBuy.inspectFuncBuy(ctx, user, item)
	}

	mm_params := UserServiceMockBuyParams{ctx, user, item}

	// Record call args
	mmBuy.BuyMock.mutex.Lock()
	mmBuy.BuyMock.callArgs = append(mmBuy.BuyMock.callArgs, &mm_params)
	mmBuy.BuyMock.mutex.Unlock()

	for _, e := range mmBuy.BuyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmBuy.BuyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBuy.BuyMock.defaultExpectation.Counter, 1)
		mm_want := mmBuy.BuyMock.defaultExpectation.params
		mm_want_ptrs := mmBuy.BuyMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockBuyParams{ctx, user, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmBuy.t.Errorf("UserServiceMock.Buy got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBuy.BuyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmBuy.t.Errorf("UserServiceMock.Buy got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBuy.BuyMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmBuy.t.Errorf("UserServiceMock.Buy got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBuy.BuyMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBuy.t.Errorf("UserServiceMock.Buy got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmBuy.BuyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBuy.BuyMock.defaultExpectation.results
		if mm_results == nil {
			mmBuy.t.Fatal("No results are set for the UserServiceMock.Buy")
		}
		return (*mm_results).err
	}
	if mmBuy.funcBuy != nil {
		return mmBuy.funcBuy(ctx, user, item)
	}
	mmBuy.t.Fatalf("Unexpected call to UserServiceMock.Buy. %v %v %v", ctx, user, item)
	return
}

// BuyAfterCounter returns a count of finished UserServiceMock.Buy invocations
func (mmBuy *UserServiceMock) BuyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuy.afterBuyCounter)
}

// BuyBeforeCounter returns a count of UserServiceMock.Buy invocations
func (mmBuy *UserServiceMock) BuyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuy.beforeBuyCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.Buy.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBuy *mUserServiceMockBuy) Calls() []*UserServiceMockBuyParams {
	mmBuy.mutex.RLock()

	argCopy := make([]*UserServiceMockBuyParams, len(mmBuy.callArgs))
	copy(argCopy, mmBuy.callArgs)

	mmBuy.mutex.RUnlock()

	return argCopy
}

// MinimockBuyDone returns true if the count of the Buy invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockBuyDone() bool {
	if m.BuyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BuyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BuyMock.invocationsDone()
}

// MinimockBuyInspect logs each unmet expectation
func (m *UserServiceMock) MinimockBuyInspect() {
	for _, e := range m.BuyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.Buy at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterBuyCounter := mm_atomic.LoadUint64(&m.afterBuyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BuyMock.defaultExpectation != nil && afterBuyCounter < 1 {
		if m.BuyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserServiceMock.Buy at\n%s", m.BuyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserServiceMock.Buy at\n%s with params: %#v", m.BuyMock.defaultExpectation.expectationOrigins.origin, *m.BuyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuy != nil && afterBuyCounter < 1 {
		m.t.Errorf("Expected call to UserServiceMock.Buy at\n%s", m.funcBuyOrigin)
	}

	if !m.BuyMock.invocationsDone() && afterBuyCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.Buy at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.BuyMock.expectedInvocations), m.BuyMock.expectedInvocationsOrigin, afterBuyCounter)
	}
}

type mUserServiceMockGetUserByName struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockGetUserByNameExpectation
	expectations       []*UserServiceMockGetUserByNameExpectation

	callArgs []*UserServiceMockGetUserByNameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserServiceMockGetUserByNameExpectation specifies expectation struct of the UserService.GetUserByName
type UserServiceMockGetUserByNameExpectation struct {
	mock               *UserServiceMock
	params             *UserServiceMockGetUserByNameParams
	paramPtrs          *UserServiceMockGetUserByNameParamPtrs
	expectationOrigins UserServiceMockGetUserByNameExpectationOrigins
	results            *UserServiceMockGetUserByNameResults
	returnOrigin       string
	Counter            uint64
}

// UserServiceMockGetUserByNameParams contains parameters of the UserService.GetUserByName
type UserServiceMockGetUserByNameParams struct {
	ctx  context.Context
	name string
}

// UserServiceMockGetUserByNameParamPtrs contains pointers to parameters of the UserService.GetUserByName
type UserServiceMockGetUserByNameParamPtrs struct {
	ctx  *context.Context
	name *string
}

// UserServiceMockGetUserByNameResults contains results of the UserService.GetUserByName
type UserServiceMockGetUserByNameResults struct {
	up1 *model.User
	err error
}

// UserServiceMockGetUserByNameOrigins contains origins of expectations of the UserService.GetUserByName
type UserServiceMockGetUserByNameExpectationOrigins struct {
	origin     string
	originCtx  string
	originName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserByName *mUserServiceMockGetUserByName) Optional() *mUserServiceMockGetUserByName {
	mmGetUserByName.optional = true
	return mmGetUserByName
}

// Expect sets up expected params for UserService.GetUserByName
func (mmGetUserByName *mUserServiceMockGetUserByName) Expect(ctx context.Context, name string) *mUserServiceMockGetUserByName {
	if mmGetUserByName.mock.funcGetUserByName != nil {
		mmGetUserByName.mock.t.Fatalf("UserServiceMock.GetUserByName mock is already set by Set")
	}

	if mmGetUserByName.defaultExpectation == nil {
		mmGetUserByName.defaultExpectation = &UserServiceMockGetUserByNameExpectation{}
	}

	if mmGetUserByName.defaultExpectation.paramPtrs != nil {
		mmGetUserByName.mock.t.Fatalf("UserServiceMock.GetUserByName mock is already set by ExpectParams functions")
	}

	mmGetUserByName.defaultExpectation.params = &UserServiceMockGetUserByNameParams{ctx, name}
	mmGetUserByName.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserByName.expectations {
		if minimock.Equal(e.params, mmGetUserByName.defaultExpectation.params) {
			mmGetUserByName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByName.defaultExpectation.params)
		}
	}

	return mmGetUserByName
}

// ExpectCtxParam1 sets up expected param ctx for UserService.GetUserByName
func (mmGetUserByName *mUserServiceMockGetUserByName) ExpectCtxParam1(ctx context.Context) *mUserServiceMockGetUserByName {
	if mmGetUserByName.mock.funcGetUserByName != nil {
		mmGetUserByName.mock.t.Fatalf("UserServiceMock.GetUserByName mock is already set by Set")
	}

	if mmGetUserByName.defaultExpectation == nil {
		mmGetUserByName.defaultExpectation = &UserServiceMockGetUserByNameExpectation{}
	}

	if mmGetUserByName.defaultExpectation.params != nil {
		mmGetUserByName.mock.t.Fatalf("UserServiceMock.GetUserByName mock is already set by Expect")
	}

	if mmGetUserByName.defaultExpectation.paramPtrs == nil {
		mmGetUserByName.defaultExpectation.paramPtrs = &UserServiceMockGetUserByNameParamPtrs{}
	}
	mmGetUserByName.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserByName.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserByName
}

// ExpectNameParam2 sets up expected param name for UserService.GetUserByName
func (mmGetUserByName *mUserServiceMockGetUserByName) ExpectNameParam2(name string) *mUserServiceMockGetUserByName {
	if mmGetUserByName.mock.funcGetUserByName != nil {
		mmGetUserByName.mock.t.Fatalf("UserServiceMock.GetUserByName mock is already set by Set")
	}

	if mmGetUserByName.defaultExpectation == nil {
		mmGetUserByName.defaultExpectation = &UserServiceMockGetUserByNameExpectation{}
	}

	if mmGetUserByName.defaultExpectation.params != nil {
		mmGetUserByName.mock.t.Fatalf("UserServiceMock.GetUserByName mock is already set by Expect")
	}

	if mmGetUserByName.defaultExpectation.paramPtrs == nil {
		mmGetUserByName.defaultExpectation.paramPtrs = &UserServiceMockGetUserByNameParamPtrs{}
	}
	mmGetUserByName.defaultExpectation.paramPtrs.name = &name
	mmGetUserByName.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmGetUserByName
}

// Inspect accepts an inspector function that has same arguments as the UserService.GetUserByName
func (mmGetUserByName *mUserServiceMockGetUserByName) Inspect(f func(ctx context.Context, name string)) *mUserServiceMockGetUserByName {
	if mmGetUserByName.mock.inspectFuncGetUserByName != nil {
		mmGetUserByName.mock.t.Fatalf("Inspect function is already set for UserServiceMock.GetUserByName")
	}

	mmGetUserByName.mock.inspectFuncGetUserByName = f

	return mmGetUserByName
}

// Return sets up results that will be returned by UserService.GetUserByName
func (mmGetUserByName *mUserServiceMockGetUserByName) Return(up1 *model.User, err error) *UserServiceMock {
	if mmGetUserByName.mock.funcGetUserByName != nil {
		mmGetUserByName.mock.t.Fatalf("UserServiceMock.GetUserByName mock is already set by Set")
	}

	if mmGetUserByName.defaultExpectation == nil {
		mmGetUserByName.defaultExpectation = &UserServiceMockGetUserByNameExpectation{mock: mmGetUserByName.mock}
	}
	mmGetUserByName.defaultExpectation.results = &UserServiceMockGetUserByNameResults{up1, err}
	mmGetUserByName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserByName.mock
}

// Set uses given function f to mock the UserService.GetUserByName method
func (mmGetUserByName *mUserServiceMockGetUserByName) Set(f func(ctx context.Context, name string) (up1 *model.User, err error)) *UserServiceMock {
	if mmGetUserByName.defaultExpectation != nil {
		mmGetUserByName.mock.t.Fatalf("Default expectation is already set for the UserService.GetUserByName method")
	}

	if len(mmGetUserByName.expectations) > 0 {
		mmGetUserByName.mock.t.Fatalf("Some expectations are already set for the UserService.GetUserByName method")
	}

	mmGetUserByName.mock.funcGetUserByName = f
	mmGetUserByName.mock.funcGetUserByNameOrigin = minimock.CallerInfo(1)
	return mmGetUserByName.mock
}

// When sets expectation for the UserService.GetUserByName which will trigger the result defined by the following
// Then helper
func (mmGetUserByName *mUserServiceMockGetUserByName) When(ctx context.Context, name string) *UserServiceMockGetUserByNameExpectation {
	if mmGetUserByName.mock.funcGetUserByName != nil {
		mmGetUserByName.mock.t.Fatalf("UserServiceMock.GetUserByName mock is already set by Set")
	}

	expectation := &UserServiceMockGetUserByNameExpectation{
		mock:               mmGetUserByName.mock,
		params:             &UserServiceMockGetUserByNameParams{ctx, name},
		expectationOrigins: UserServiceMockGetUserByNameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserByName.expectations = append(mmGetUserByName.expectations, expectation)
	return expectation
}

// Then sets up UserService.GetUserByName return parameters for the expectation previously defined by the When method
func (e *UserServiceMockGetUserByNameExpectation) Then(up1 *model.User, err error) *UserServiceMock {
	e.results = &UserServiceMockGetUserByNameResults{up1, err}
	return e.mock
}

// Times sets number of times UserService.GetUserByName should be invoked
func (mmGetUserByName *mUserServiceMockGetUserByName) Times(n uint64) *mUserServiceMockGetUserByName {
	if n == 0 {
		mmGetUserByName.mock.t.Fatalf("Times of UserServiceMock.GetUserByName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserByName.expectedInvocations, n)
	mmGetUserByName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserByName
}

func (mmGetUserByName *mUserServiceMockGetUserByName) invocationsDone() bool {
	if len(mmGetUserByName.expectations) == 0 && mmGetUserByName.defaultExpectation == nil && mmGetUserByName.mock.funcGetUserByName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserByName.mock.afterGetUserByNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserByName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserByName implements mm_service.UserService
func (mmGetUserByName *UserServiceMock) GetUserByName(ctx context.Context, name string) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGetUserByName.beforeGetUserByNameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByName.afterGetUserByNameCounter, 1)

	mmGetUserByName.t.Helper()

	if mmGetUserByName.inspectFuncGetUserByName != nil {
		mmGetUserByName.inspectFuncGetUserByName(ctx, name)
	}

	mm_params := UserServiceMockGetUserByNameParams{ctx, name}

	// Record call args
	mmGetUserByName.GetUserByNameMock.mutex.Lock()
	mmGetUserByName.GetUserByNameMock.callArgs = append(mmGetUserByName.GetUserByNameMock.callArgs, &mm_params)
	mmGetUserByName.GetUserByNameMock.mutex.Unlock()

	for _, e := range mmGetUserByName.GetUserByNameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserByName.GetUserByNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByName.GetUserByNameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByName.GetUserByNameMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserByName.GetUserByNameMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockGetUserByNameParams{ctx, name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserByName.t.Errorf("UserServiceMock.GetUserByName got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByName.GetUserByNameMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmGetUserByName.t.Errorf("UserServiceMock.GetUserByName got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByName.GetUserByNameMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByName.t.Errorf("UserServiceMock.GetUserByName got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserByName.GetUserByNameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByName.GetUserByNameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByName.t.Fatal("No results are set for the UserServiceMock.GetUserByName")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserByName.funcGetUserByName != nil {
		return mmGetUserByName.funcGetUserByName(ctx, name)
	}
	mmGetUserByName.t.Fatalf("Unexpected call to UserServiceMock.GetUserByName. %v %v", ctx, name)
	return
}

// GetUserByNameAfterCounter returns a count of finished UserServiceMock.GetUserByName invocations
func (mmGetUserByName *UserServiceMock) GetUserByNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByName.afterGetUserByNameCounter)
}

// GetUserByNameBeforeCounter returns a count of UserServiceMock.GetUserByName invocations
func (mmGetUserByName *UserServiceMock) GetUserByNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByName.beforeGetUserByNameCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.GetUserByName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByName *mUserServiceMockGetUserByName) Calls() []*UserServiceMockGetUserByNameParams {
	mmGetUserByName.mutex.RLock()

	argCopy := make([]*UserServiceMockGetUserByNameParams, len(mmGetUserByName.callArgs))
	copy(argCopy, mmGetUserByName.callArgs)

	mmGetUserByName.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByNameDone returns true if the count of the GetUserByName invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockGetUserByNameDone() bool {
	if m.GetUserByNameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserByNameMock.invocationsDone()
}

// MinimockGetUserByNameInspect logs each unmet expectation
func (m *UserServiceMock) MinimockGetUserByNameInspect() {
	for _, e := range m.GetUserByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.GetUserByName at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserByNameCounter := mm_atomic.LoadUint64(&m.afterGetUserByNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByNameMock.defaultExpectation != nil && afterGetUserByNameCounter < 1 {
		if m.GetUserByNameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserServiceMock.GetUserByName at\n%s", m.GetUserByNameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserServiceMock.GetUserByName at\n%s with params: %#v", m.GetUserByNameMock.defaultExpectation.expectationOrigins.origin, *m.GetUserByNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByName != nil && afterGetUserByNameCounter < 1 {
		m.t.Errorf("Expected call to UserServiceMock.GetUserByName at\n%s", m.funcGetUserByNameOrigin)
	}

	if !m.GetUserByNameMock.invocationsDone() && afterGetUserByNameCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.GetUserByName at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserByNameMock.expectedInvocations), m.GetUserByNameMock.expectedInvocationsOrigin, afterGetUserByNameCounter)
	}
}

type mUserServiceMockGetUserInfo struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockGetUserInfoExpectation
	expectations       []*UserServiceMockGetUserInfoExpectation

	callArgs []*UserServiceMockGetUserInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserServiceMockGetUserInfoExpectation specifies expectation struct of the UserService.GetUserInfo
type UserServiceMockGetUserInfoExpectation struct {
	mock               *UserServiceMock
	params             *UserServiceMockGetUserInfoParams
	paramPtrs          *UserServiceMockGetUserInfoParamPtrs
	expectationOrigins UserServiceMockGetUserInfoExpectationOrigins
	results            *UserServiceMockGetUserInfoResults
	returnOrigin       string
	Counter            uint64
}

// UserServiceMockGetUserInfoParams contains parameters of the UserService.GetUserInfo
type UserServiceMockGetUserInfoParams struct {
	ctx    context.Context
	userID int64
}

// UserServiceMockGetUserInfoParamPtrs contains pointers to parameters of the UserService.GetUserInfo
type UserServiceMockGetUserInfoParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// UserServiceMockGetUserInfoResults contains results of the UserService.GetUserInfo
type UserServiceMockGetUserInfoResults struct {
	i1  model.InfoResponse
	err error
}

// UserServiceMockGetUserInfoOrigins contains origins of expectations of the UserService.GetUserInfo
type UserServiceMockGetUserInfoExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserInfo *mUserServiceMockGetUserInfo) Optional() *mUserServiceMockGetUserInfo {
	mmGetUserInfo.optional = true
	return mmGetUserInfo
}

// Expect sets up expected params for UserService.GetUserInfo
func (mmGetUserInfo *mUserServiceMockGetUserInfo) Expect(ctx context.Context, userID int64) *mUserServiceMockGetUserInfo {
	if mmGetUserInfo.mock.funcGetUserInfo != nil {
		mmGetUserInfo.mock.t.Fatalf("UserServiceMock.GetUserInfo mock is already set by Set")
	}

	if mmGetUserInfo.defaultExpectation == nil {
		mmGetUserInfo.defaultExpectation = &UserServiceMockGetUserInfoExpectation{}
	}

	if mmGetUserInfo.defaultExpectation.paramPtrs != nil {
		mmGetUserInfo.mock.t.Fatalf("UserServiceMock.GetUserInfo mock is already set by ExpectParams functions")
	}

	mmGetUserInfo.defaultExpectation.params = &UserServiceMockGetUserInfoParams{ctx, userID}
	mmGetUserInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserInfo.expectations {
		if minimock.Equal(e.params, mmGetUserInfo.defaultExpectation.params) {
			mmGetUserInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserInfo.defaultExpectation.params)
		}
	}

	return mmGetUserInfo
}

// ExpectCtxParam1 sets up expected param ctx for UserService.GetUserInfo
func (mmGetUserInfo *mUserServiceMockGetUserInfo) ExpectCtxParam1(ctx context.Context) *mUserServiceMockGetUserInfo {
	if mmGetUserInfo.mock.funcGetUserInfo != nil {
		mmGetUserInfo.mock.t.Fatalf("UserServiceMock.GetUserInfo mock is already set by Set")
	}

	if mmGetUserInfo.defaultExpectation == nil {
		mmGetUserInfo.defaultExpectation = &UserServiceMockGetUserInfoExpectation{}
	}

	if mmGetUserInfo.defaultExpectation.params != nil {
		mmGetUserInfo.mock.t.Fatalf("UserServiceMock.GetUserInfo mock is already set by Expect")
	}

	if mmGetUserInfo.defaultExpectation.paramPtrs == nil {
		mmGetUserInfo.defaultExpectation.paramPtrs = &UserServiceMockGetUserInfoParamPtrs{}
	}
	mmGetUserInfo.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserInfo.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserInfo
}

// ExpectUserIDParam2 sets up expected param userID for UserService.GetUserInfo
func (mmGetUserInfo *mUserServiceMockGetUserInfo) ExpectUserIDParam2(userID int64) *mUserServiceMockGetUserInfo {
	if mmGetUserInfo.mock.funcGetUserInfo != nil {
		mmGetUserInfo.mock.t.Fatalf("UserServiceMock.GetUserInfo mock is already set by Set")
	}

	if mmGetUserInfo.defaultExpectation == nil {
		mmGetUserInfo.defaultExpectation = &UserServiceMockGetUserInfoExpectation{}
	}

	if mmGetUserInfo.defaultExpectation.params != nil {
		mmGetUserInfo.mock.t.Fatalf("UserServiceMock.GetUserInfo mock is already set by Expect")
	}

	if mmGetUserInfo.defaultExpectation.paramPtrs == nil {
		mmGetUserInfo.defaultExpectation.paramPtrs = &UserServiceMockGetUserInfoParamPtrs{}
	}
	mmGetUserInfo.defaultExpectation.paramPtrs.userID = &userID
	mmGetUserInfo.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetUserInfo
}

// Inspect accepts an inspector function that has same arguments as the UserService.GetUserInfo
func (mmGetUserInfo *mUserServiceMockGetUserInfo) Inspect(f func(ctx context.Context, userID int64)) *mUserServiceMockGetUserInfo {
	if mmGetUserInfo.mock.inspectFuncGetUserInfo != nil {
		mmGetUserInfo.mock.t.Fatalf("Inspect function is already set for UserServiceMock.GetUserInfo")
	}

	mmGetUserInfo.mock.inspectFuncGetUserInfo = f

	return mmGetUserInfo
}

// Return sets up results that will be returned by UserService.GetUserInfo
func (mmGetUserInfo *mUserServiceMockGetUserInfo) Return(i1 model.InfoResponse, err error) *UserServiceMock {
	if mmGetUserInfo.mock.funcGetUserInfo != nil {
		mmGetUserInfo.mock.t.Fatalf("UserServiceMock.GetUserInfo mock is already set by Set")
	}

	if mmGetUserInfo.defaultExpectation == nil {
		mmGetUserInfo.defaultExpectation = &UserServiceMockGetUserInfoExpectation{mock: mmGetUserInfo.mock}
	}
	mmGetUserInfo.defaultExpectation.results = &UserServiceMockGetUserInfoResults{i1, err}
	mmGetUserInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserInfo.mock
}

// Set uses given function f to mock the UserService.GetUserInfo method
func (mmGetUserInfo *mUserServiceMockGetUserInfo) Set(f func(ctx context.Context, userID int64) (i1 model.InfoResponse, err error)) *UserServiceMock {
	if mmGetUserInfo.defaultExpectation != nil {
		mmGetUserInfo.mock.t.Fatalf("Default expectation is already set for the UserService.GetUserInfo method")
	}

	if len(mmGetUserInfo.expectations) > 0 {
		mmGetUserInfo.mock.t.Fatalf("Some expectations are already set for the UserService.GetUserInfo method")
	}

	mmGetUserInfo.mock.funcGetUserInfo = f
	mmGetUserInfo.mock.funcGetUserInfoOrigin = minimock.CallerInfo(1)
	return mmGetUserInfo.mock
}

// When sets expectation for the UserService.GetUserInfo which will trigger the result defined by the following
// Then helper
func (mmGetUserInfo *mUserServiceMockGetUserInfo) When(ctx context.Context, userID int64) *UserServiceMockGetUserInfoExpectation {
	if mmGetUserInfo.mock.funcGetUserInfo != nil {
		mmGetUserInfo.mock.t.Fatalf("UserServiceMock.GetUserInfo mock is already set by Set")
	}

	expectation := &UserServiceMockGetUserInfoExpectation{
		mock:               mmGetUserInfo.mock,
		params:             &UserServiceMockGetUserInfoParams{ctx, userID},
		expectationOrigins: UserServiceMockGetUserInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserInfo.expectations = append(mmGetUserInfo.expectations, expectation)
	return expectation
}

// Then sets up UserService.GetUserInfo return parameters for the expectation previously defined by the When method
func (e *UserServiceMockGetUserInfoExpectation) Then(i1 model.InfoResponse, err error) *UserServiceMock {
	e.results = &UserServiceMockGetUserInfoResults{i1, err}
	return e.mock
}

// Times sets number of times UserService.GetUserInfo should be invoked
func (mmGetUserInfo *mUserServiceMockGetUserInfo) Times(n uint64) *mUserServiceMockGetUserInfo {
	if n == 0 {
		mmGetUserInfo.mock.t.Fatalf("Times of UserServiceMock.GetUserInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserInfo.expectedInvocations, n)
	mmGetUserInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserInfo
}

func (mmGetUserInfo *mUserServiceMockGetUserInfo) invocationsDone() bool {
	if len(mmGetUserInfo.expectations) == 0 && mmGetUserInfo.defaultExpectation == nil && mmGetUserInfo.mock.funcGetUserInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserInfo.mock.afterGetUserInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserInfo implements mm_service.UserService
func (mmGetUserInfo *UserServiceMock) GetUserInfo(ctx context.Context, userID int64) (i1 model.InfoResponse, err error) {
	mm_atomic.AddUint64(&mmGetUserInfo.beforeGetUserInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserInfo.afterGetUserInfoCounter, 1)

	mmGetUserInfo.t.Helper()

	if mmGetUserInfo.inspectFuncGetUserInfo != nil {
		mmGetUserInfo.inspectFuncGetUserInfo(ctx, userID)
	}

	mm_params := UserServiceMockGetUserInfoParams{ctx, userID}

	// Record call args
	mmGetUserInfo.GetUserInfoMock.mutex.Lock()
	mmGetUserInfo.GetUserInfoMock.callArgs = append(mmGetUserInfo.GetUserInfoMock.callArgs, &mm_params)
	mmGetUserInfo.GetUserInfoMock.mutex.Unlock()

	for _, e := range mmGetUserInfo.GetUserInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetUserInfo.GetUserInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserInfo.GetUserInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserInfo.GetUserInfoMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserInfo.GetUserInfoMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockGetUserInfoParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserInfo.t.Errorf("UserServiceMock.GetUserInfo got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserInfo.GetUserInfoMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetUserInfo.t.Errorf("UserServiceMock.GetUserInfo got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserInfo.GetUserInfoMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserInfo.t.Errorf("UserServiceMock.GetUserInfo got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserInfo.GetUserInfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserInfo.GetUserInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserInfo.t.Fatal("No results are set for the UserServiceMock.GetUserInfo")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetUserInfo.funcGetUserInfo != nil {
		return mmGetUserInfo.funcGetUserInfo(ctx, userID)
	}
	mmGetUserInfo.t.Fatalf("Unexpected call to UserServiceMock.GetUserInfo. %v %v", ctx, userID)
	return
}

// GetUserInfoAfterCounter returns a count of finished UserServiceMock.GetUserInfo invocations
func (mmGetUserInfo *UserServiceMock) GetUserInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserInfo.afterGetUserInfoCounter)
}

// GetUserInfoBeforeCounter returns a count of UserServiceMock.GetUserInfo invocations
func (mmGetUserInfo *UserServiceMock) GetUserInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserInfo.beforeGetUserInfoCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.GetUserInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserInfo *mUserServiceMockGetUserInfo) Calls() []*UserServiceMockGetUserInfoParams {
	mmGetUserInfo.mutex.RLock()

	argCopy := make([]*UserServiceMockGetUserInfoParams, len(mmGetUserInfo.callArgs))
	copy(argCopy, mmGetUserInfo.callArgs)

	mmGetUserInfo.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserInfoDone returns true if the count of the GetUserInfo invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockGetUserInfoDone() bool {
	if m.GetUserInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserInfoMock.invocationsDone()
}

// MinimockGetUserInfoInspect logs each unmet expectation
func (m *UserServiceMock) MinimockGetUserInfoInspect() {
	for _, e := range m.GetUserInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.GetUserInfo at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserInfoCounter := mm_atomic.LoadUint64(&m.afterGetUserInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserInfoMock.defaultExpectation != nil && afterGetUserInfoCounter < 1 {
		if m.GetUserInfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserServiceMock.GetUserInfo at\n%s", m.GetUserInfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserServiceMock.GetUserInfo at\n%s with params: %#v", m.GetUserInfoMock.defaultExpectation.expectationOrigins.origin, *m.GetUserInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserInfo != nil && afterGetUserInfoCounter < 1 {
		m.t.Errorf("Expected call to UserServiceMock.GetUserInfo at\n%s", m.funcGetUserInfoOrigin)
	}

	if !m.GetUserInfoMock.invocationsDone() && afterGetUserInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.GetUserInfo at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserInfoMock.expectedInvocations), m.GetUserInfoMock.expectedInvocationsOrigin, afterGetUserInfoCounter)
	}
}

type mUserServiceMockSendCoins struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockSendCoinsExpectation
	expectations       []*UserServiceMockSendCoinsExpectation

	callArgs []*UserServiceMockSendCoinsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserServiceMockSendCoinsExpectation specifies expectation struct of the UserService.SendCoins
type UserServiceMockSendCoinsExpectation struct {
	mock               *UserServiceMock
	params             *UserServiceMockSendCoinsParams
	paramPtrs          *UserServiceMockSendCoinsParamPtrs
	expectationOrigins UserServiceMockSendCoinsExpectationOrigins
	results            *UserServiceMockSendCoinsResults
	returnOrigin       string
	Counter            uint64
}

// UserServiceMockSendCoinsParams contains parameters of the UserService.SendCoins
type UserServiceMockSendCoinsParams struct {
	ctx       context.Context
	userID    int64
	SendCoins model.SendCoinRequest
}

// UserServiceMockSendCoinsParamPtrs contains pointers to parameters of the UserService.SendCoins
type UserServiceMockSendCoinsParamPtrs struct {
	ctx       *context.Context
	userID    *int64
	SendCoins *model.SendCoinRequest
}

// UserServiceMockSendCoinsResults contains results of the UserService.SendCoins
type UserServiceMockSendCoinsResults struct {
	err error
}

// UserServiceMockSendCoinsOrigins contains origins of expectations of the UserService.SendCoins
type UserServiceMockSendCoinsExpectationOrigins struct {
	origin          string
	originCtx       string
	originUserID    string
	originSendCoins string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendCoins *mUserServiceMockSendCoins) Optional() *mUserServiceMockSendCoins {
	mmSendCoins.optional = true
	return mmSendCoins
}

// Expect sets up expected params for UserService.SendCoins
func (mmSendCoins *mUserServiceMockSendCoins) Expect(ctx context.Context, userID int64, SendCoins model.SendCoinRequest) *mUserServiceMockSendCoins {
	if mmSendCoins.mock.funcSendCoins != nil {
		mmSendCoins.mock.t.Fatalf("UserServiceMock.SendCoins mock is already set by Set")
	}

	if mmSendCoins.defaultExpectation == nil {
		mmSendCoins.defaultExpectation = &UserServiceMockSendCoinsExpectation{}
	}

	if mmSendCoins.defaultExpectation.paramPtrs != nil {
		mmSendCoins.mock.t.Fatalf("UserServiceMock.SendCoins mock is already set by ExpectParams functions")
	}

	mmSendCoins.defaultExpectation.params = &UserServiceMockSendCoinsParams{ctx, userID, SendCoins}
	mmSendCoins.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendCoins.expectations {
		if minimock.Equal(e.params, mmSendCoins.defaultExpectation.params) {
			mmSendCoins.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendCoins.defaultExpectation.params)
		}
	}

	return mmSendCoins
}

// ExpectCtxParam1 sets up expected param ctx for UserService.SendCoins
func (mmSendCoins *mUserServiceMockSendCoins) ExpectCtxParam1(ctx context.Context) *mUserServiceMockSendCoins {
	if mmSendCoins.mock.funcSendCoins != nil {
		mmSendCoins.mock.t.Fatalf("UserServiceMock.SendCoins mock is already set by Set")
	}

	if mmSendCoins.defaultExpectation == nil {
		mmSendCoins.defaultExpectation = &UserServiceMockSendCoinsExpectation{}
	}

	if mmSendCoins.defaultExpectation.params != nil {
		mmSendCoins.mock.t.Fatalf("UserServiceMock.SendCoins mock is already set by Expect")
	}

	if mmSendCoins.defaultExpectation.paramPtrs == nil {
		mmSendCoins.defaultExpectation.paramPtrs = &UserServiceMockSendCoinsParamPtrs{}
	}
	mmSendCoins.defaultExpectation.paramPtrs.ctx = &ctx
	mmSendCoins.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSendCoins
}

// ExpectUserIDParam2 sets up expected param userID for UserService.SendCoins
func (mmSendCoins *mUserServiceMockSendCoins) ExpectUserIDParam2(userID int64) *mUserServiceMockSendCoins {
	if mmSendCoins.mock.funcSendCoins != nil {
		mmSendCoins.mock.t.Fatalf("UserServiceMock.SendCoins mock is already set by Set")
	}

	if mmSendCoins.defaultExpectation == nil {
		mmSendCoins.defaultExpectation = &UserServiceMockSendCoinsExpectation{}
	}

	if mmSendCoins.defaultExpectation.params != nil {
		mmSendCoins.mock.t.Fatalf("UserServiceMock.SendCoins mock is already set by Expect")
	}

	if mmSendCoins.defaultExpectation.paramPtrs == nil {
		mmSendCoins.defaultExpectation.paramPtrs = &UserServiceMockSendCoinsParamPtrs{}
	}
	mmSendCoins.defaultExpectation.paramPtrs.userID = &userID
	mmSendCoins.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmSendCoins
}

// ExpectSendCoinsParam3 sets up expected param SendCoins for UserService.SendCoins
func (mmSendCoins *mUserServiceMockSendCoins) ExpectSendCoinsParam3(SendCoins model.SendCoinRequest) *mUserServiceMockSendCoins {
	if mmSendCoins.mock.funcSendCoins != nil {
		mmSendCoins.mock.t.Fatalf("UserServiceMock.SendCoins mock is already set by Set")
	}

	if mmSendCoins.defaultExpectation == nil {
		mmSendCoins.defaultExpectation = &UserServiceMockSendCoinsExpectation{}
	}

	if mmSendCoins.defaultExpectation.params != nil {
		mmSendCoins.mock.t.Fatalf("UserServiceMock.SendCoins mock is already set by Expect")
	}

	if mmSendCoins.defaultExpectation.paramPtrs == nil {
		mmSendCoins.defaultExpectation.paramPtrs = &UserServiceMockSendCoinsParamPtrs{}
	}
	mmSendCoins.defaultExpectation.paramPtrs.SendCoins = &SendCoins
	mmSendCoins.defaultExpectation.expectationOrigins.originSendCoins = minimock.CallerInfo(1)

	return mmSendCoins
}

// Inspect accepts an inspector function that has same arguments as the UserService.SendCoins
func (mmSendCoins *mUserServiceMockSendCoins) Inspect(f func(ctx context.Context, userID int64, SendCoins model.SendCoinRequest)) *mUserServiceMockSendCoins {
	if mmSendCoins.mock.inspectFuncSendCoins != nil {
		mmSendCoins.mock.t.Fatalf("Inspect function is already set for UserServiceMock.SendCoins")
	}

	mmSendCoins.mock.inspectFuncSendCoins = f

	return mmSendCoins
}

// Return sets up results that will be returned by UserService.SendCoins
func (mmSendCoins *mUserServiceMockSendCoins) Return(err error) *UserServiceMock {
	if mmSendCoins.mock.funcSendCoins != nil {
		mmSendCoins.mock.t.Fatalf("UserServiceMock.SendCoins mock is already set by Set")
	}

	if mmSendCoins.defaultExpectation == nil {
		mmSendCoins.defaultExpectation = &UserServiceMockSendCoinsExpectation{mock: mmSendCoins.mock}
	}
	mmSendCoins.defaultExpectation.results = &UserServiceMockSendCoinsResults{err}
	mmSendCoins.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendCoins.mock
}

// Set uses given function f to mock the UserService.SendCoins method
func (mmSendCoins *mUserServiceMockSendCoins) Set(f func(ctx context.Context, userID int64, SendCoins model.SendCoinRequest) (err error)) *UserServiceMock {
	if mmSendCoins.defaultExpectation != nil {
		mmSendCoins.mock.t.Fatalf("Default expectation is already set for the UserService.SendCoins method")
	}

	if len(mmSendCoins.expectations) > 0 {
		mmSendCoins.mock.t.Fatalf("Some expectations are already set for the UserService.SendCoins method")
	}

	mmSendCoins.mock.funcSendCoins = f
	mmSendCoins.mock.funcSendCoinsOrigin = minimock.CallerInfo(1)
	return mmSendCoins.mock
}

// When sets expectation for the UserService.SendCoins which will trigger the result defined by the following
// Then helper
func (mmSendCoins *mUserServiceMockSendCoins) When(ctx context.Context, userID int64, SendCoins model.SendCoinRequest) *UserServiceMockSendCoinsExpectation {
	if mmSendCoins.mock.funcSendCoins != nil {
		mmSendCoins.mock.t.Fatalf("UserServiceMock.SendCoins mock is already set by Set")
	}

	expectation := &UserServiceMockSendCoinsExpectation{
		mock:               mmSendCoins.mock,
		params:             &UserServiceMockSendCoinsParams{ctx, userID, SendCoins},
		expectationOrigins: UserServiceMockSendCoinsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendCoins.expectations = append(mmSendCoins.expectations, expectation)
	return expectation
}

// Then sets up UserService.SendCoins return parameters for the expectation previously defined by the When method
func (e *UserServiceMockSendCoinsExpectation) Then(err error) *UserServiceMock {
	e.results = &UserServiceMockSendCoinsResults{err}
	return e.mock
}

// Times sets number of times UserService.SendCoins should be invoked
func (mmSendCoins *mUserServiceMockSendCoins) Times(n uint64) *mUserServiceMockSendCoins {
	if n == 0 {
		mmSendCoins.mock.t.Fatalf("Times of UserServiceMock.SendCoins mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendCoins.expectedInvocations, n)
	mmSendCoins.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendCoins
}

func (mmSendCoins *mUserServiceMockSendCoins) invocationsDone() bool {
	if len(mmSendCoins.expectations) == 0 && mmSendCoins.defaultExpectation == nil && mmSendCoins.mock.funcSendCoins == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendCoins.mock.afterSendCoinsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendCoins.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendCoins implements mm_service.UserService
func (mmSendCoins *UserServiceMock) SendCoins(ctx context.Context, userID int64, SendCoins model.SendCoinRequest) (err error) {
	mm_atomic.AddUint64(&mmSendCoins.beforeSendCoinsCounter, 1)
	defer mm_atomic.AddUint64(&mmSendCoins.afterSendCoinsCounter, 1)

	mmSendCoins.t.Helper()

	if mmSendCoins.inspectFuncSendCoins != nil {
		mmSendCoins.inspectFuncSendCoins(ctx, userID, SendCoins)
	}

	mm_params := UserServiceMockSendCoinsParams{ctx, userID, SendCoins}

	// Record call args
	mmSendCoins.SendCoinsMock.mutex.Lock()
	mmSendCoins.SendCoinsMock.callArgs = append(mmSendCoins.SendCoinsMock.callArgs, &mm_params)
	mmSendCoins.SendCoinsMock.mutex.Unlock()

	for _, e := range mmSendCoins.SendCoinsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendCoins.SendCoinsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendCoins.SendCoinsMock.defaultExpectation.Counter, 1)
		mm_want := mmSendCoins.SendCoinsMock.defaultExpectation.params
		mm_want_ptrs := mmSendCoins.SendCoinsMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockSendCoinsParams{ctx, userID, SendCoins}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendCoins.t.Errorf("UserServiceMock.SendCoins got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendCoins.SendCoinsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmSendCoins.t.Errorf("UserServiceMock.SendCoins got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendCoins.SendCoinsMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.SendCoins != nil && !minimock.Equal(*mm_want_ptrs.SendCoins, mm_got.SendCoins) {
				mmSendCoins.t.Errorf("UserServiceMock.SendCoins got unexpected parameter SendCoins, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendCoins.SendCoinsMock.defaultExpectation.expectationOrigins.originSendCoins, *mm_want_ptrs.SendCoins, mm_got.SendCoins, minimock.Diff(*mm_want_ptrs.SendCoins, mm_got.SendCoins))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendCoins.t.Errorf("UserServiceMock.SendCoins got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendCoins.SendCoinsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendCoins.SendCoinsMock.defaultExpectation.results
		if mm_results == nil {
			mmSendCoins.t.Fatal("No results are set for the UserServiceMock.SendCoins")
		}
		return (*mm_results).err
	}
	if mmSendCoins.funcSendCoins != nil {
		return mmSendCoins.funcSendCoins(ctx, userID, SendCoins)
	}
	mmSendCoins.t.Fatalf("Unexpected call to UserServiceMock.SendCoins. %v %v %v", ctx, userID, SendCoins)
	return
}

// SendCoinsAfterCounter returns a count of finished UserServiceMock.SendCoins invocations
func (mmSendCoins *UserServiceMock) SendCoinsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendCoins.afterSendCoinsCounter)
}

// SendCoinsBeforeCounter returns a count of UserServiceMock.SendCoins invocations
func (mmSendCoins *UserServiceMock) SendCoinsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendCoins.beforeSendCoinsCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.SendCoins.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendCoins *mUserServiceMockSendCoins) Calls() []*UserServiceMockSendCoinsParams {
	mmSendCoins.mutex.RLock()

	argCopy := make([]*UserServiceMockSendCoinsParams, len(mmSendCoins.callArgs))
	copy(argCopy, mmSendCoins.callArgs)

	mmSendCoins.mutex.RUnlock()

	return argCopy
}

// MinimockSendCoinsDone returns true if the count of the SendCoins invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockSendCoinsDone() bool {
	if m.SendCoinsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendCoinsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendCoinsMock.invocationsDone()
}

// MinimockSendCoinsInspect logs each unmet expectation
func (m *UserServiceMock) MinimockSendCoinsInspect() {
	for _, e := range m.SendCoinsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.SendCoins at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendCoinsCounter := mm_atomic.LoadUint64(&m.afterSendCoinsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendCoinsMock.defaultExpectation != nil && afterSendCoinsCounter < 1 {
		if m.SendCoinsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserServiceMock.SendCoins at\n%s", m.SendCoinsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserServiceMock.SendCoins at\n%s with params: %#v", m.SendCoinsMock.defaultExpectation.expectationOrigins.origin, *m.SendCoinsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendCoins != nil && afterSendCoinsCounter < 1 {
		m.t.Errorf("Expected call to UserServiceMock.SendCoins at\n%s", m.funcSendCoinsOrigin)
	}

	if !m.SendCoinsMock.invocationsDone() && afterSendCoinsCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.SendCoins at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendCoinsMock.expectedInvocations), m.SendCoinsMock.expectedInvocationsOrigin, afterSendCoinsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBuyInspect()

			m.MinimockGetUserByNameInspect()

			m.MinimockGetUserInfoInspect()

			m.MinimockSendCoinsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBuyDone() &&
		m.MinimockGetUserByNameDone() &&
		m.MinimockGetUserInfoDone() &&
		m.MinimockSendCoinsDone()
}
