// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/merynayr/AvitoShop/internal/repository.ShopRepository -o shop_repository_minimock.go -n ShopRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/merynayr/AvitoShop/internal/model"
)

// ShopRepositoryMock implements mm_repository.ShopRepository
type ShopRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckInventory          func(ctx context.Context, userID int64, item string) (b1 bool, i1 int64, err error)
	funcCheckInventoryOrigin    string
	inspectFuncCheckInventory   func(ctx context.Context, userID int64, item string)
	afterCheckInventoryCounter  uint64
	beforeCheckInventoryCounter uint64
	CheckInventoryMock          mShopRepositoryMockCheckInventory

	funcCreateTransaction          func(ctx context.Context, fromUserID int64, toUserID int64, amount int64) (err error)
	funcCreateTransactionOrigin    string
	inspectFuncCreateTransaction   func(ctx context.Context, fromUserID int64, toUserID int64, amount int64)
	afterCreateTransactionCounter  uint64
	beforeCreateTransactionCounter uint64
	CreateTransactionMock          mShopRepositoryMockCreateTransaction

	funcGetMerchPrice          func(ctx context.Context, item string) (i1 int64, err error)
	funcGetMerchPriceOrigin    string
	inspectFuncGetMerchPrice   func(ctx context.Context, item string)
	afterGetMerchPriceCounter  uint64
	beforeGetMerchPriceCounter uint64
	GetMerchPriceMock          mShopRepositoryMockGetMerchPrice

	funcGetUserInventory          func(ctx context.Context, userID int64) (ia1 []model.InventoryItem, err error)
	funcGetUserInventoryOrigin    string
	inspectFuncGetUserInventory   func(ctx context.Context, userID int64)
	afterGetUserInventoryCounter  uint64
	beforeGetUserInventoryCounter uint64
	GetUserInventoryMock          mShopRepositoryMockGetUserInventory

	funcGetUserTransactions          func(ctx context.Context, userID int64) (ra1 []model.Received, sa1 []model.Sent, err error)
	funcGetUserTransactionsOrigin    string
	inspectFuncGetUserTransactions   func(ctx context.Context, userID int64)
	afterGetUserTransactionsCounter  uint64
	beforeGetUserTransactionsCounter uint64
	GetUserTransactionsMock          mShopRepositoryMockGetUserTransactions

	funcInsertNewInventory          func(ctx context.Context, userID int64, item string) (err error)
	funcInsertNewInventoryOrigin    string
	inspectFuncInsertNewInventory   func(ctx context.Context, userID int64, item string)
	afterInsertNewInventoryCounter  uint64
	beforeInsertNewInventoryCounter uint64
	InsertNewInventoryMock          mShopRepositoryMockInsertNewInventory

	funcUpdateInventory          func(ctx context.Context, item string, id int64, newQuantity int64) (err error)
	funcUpdateInventoryOrigin    string
	inspectFuncUpdateInventory   func(ctx context.Context, item string, id int64, newQuantity int64)
	afterUpdateInventoryCounter  uint64
	beforeUpdateInventoryCounter uint64
	UpdateInventoryMock          mShopRepositoryMockUpdateInventory
}

// NewShopRepositoryMock returns a mock for mm_repository.ShopRepository
func NewShopRepositoryMock(t minimock.Tester) *ShopRepositoryMock {
	m := &ShopRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckInventoryMock = mShopRepositoryMockCheckInventory{mock: m}
	m.CheckInventoryMock.callArgs = []*ShopRepositoryMockCheckInventoryParams{}

	m.CreateTransactionMock = mShopRepositoryMockCreateTransaction{mock: m}
	m.CreateTransactionMock.callArgs = []*ShopRepositoryMockCreateTransactionParams{}

	m.GetMerchPriceMock = mShopRepositoryMockGetMerchPrice{mock: m}
	m.GetMerchPriceMock.callArgs = []*ShopRepositoryMockGetMerchPriceParams{}

	m.GetUserInventoryMock = mShopRepositoryMockGetUserInventory{mock: m}
	m.GetUserInventoryMock.callArgs = []*ShopRepositoryMockGetUserInventoryParams{}

	m.GetUserTransactionsMock = mShopRepositoryMockGetUserTransactions{mock: m}
	m.GetUserTransactionsMock.callArgs = []*ShopRepositoryMockGetUserTransactionsParams{}

	m.InsertNewInventoryMock = mShopRepositoryMockInsertNewInventory{mock: m}
	m.InsertNewInventoryMock.callArgs = []*ShopRepositoryMockInsertNewInventoryParams{}

	m.UpdateInventoryMock = mShopRepositoryMockUpdateInventory{mock: m}
	m.UpdateInventoryMock.callArgs = []*ShopRepositoryMockUpdateInventoryParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mShopRepositoryMockCheckInventory struct {
	optional           bool
	mock               *ShopRepositoryMock
	defaultExpectation *ShopRepositoryMockCheckInventoryExpectation
	expectations       []*ShopRepositoryMockCheckInventoryExpectation

	callArgs []*ShopRepositoryMockCheckInventoryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ShopRepositoryMockCheckInventoryExpectation specifies expectation struct of the ShopRepository.CheckInventory
type ShopRepositoryMockCheckInventoryExpectation struct {
	mock               *ShopRepositoryMock
	params             *ShopRepositoryMockCheckInventoryParams
	paramPtrs          *ShopRepositoryMockCheckInventoryParamPtrs
	expectationOrigins ShopRepositoryMockCheckInventoryExpectationOrigins
	results            *ShopRepositoryMockCheckInventoryResults
	returnOrigin       string
	Counter            uint64
}

// ShopRepositoryMockCheckInventoryParams contains parameters of the ShopRepository.CheckInventory
type ShopRepositoryMockCheckInventoryParams struct {
	ctx    context.Context
	userID int64
	item   string
}

// ShopRepositoryMockCheckInventoryParamPtrs contains pointers to parameters of the ShopRepository.CheckInventory
type ShopRepositoryMockCheckInventoryParamPtrs struct {
	ctx    *context.Context
	userID *int64
	item   *string
}

// ShopRepositoryMockCheckInventoryResults contains results of the ShopRepository.CheckInventory
type ShopRepositoryMockCheckInventoryResults struct {
	b1  bool
	i1  int64
	err error
}

// ShopRepositoryMockCheckInventoryOrigins contains origins of expectations of the ShopRepository.CheckInventory
type ShopRepositoryMockCheckInventoryExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originItem   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckInventory *mShopRepositoryMockCheckInventory) Optional() *mShopRepositoryMockCheckInventory {
	mmCheckInventory.optional = true
	return mmCheckInventory
}

// Expect sets up expected params for ShopRepository.CheckInventory
func (mmCheckInventory *mShopRepositoryMockCheckInventory) Expect(ctx context.Context, userID int64, item string) *mShopRepositoryMockCheckInventory {
	if mmCheckInventory.mock.funcCheckInventory != nil {
		mmCheckInventory.mock.t.Fatalf("ShopRepositoryMock.CheckInventory mock is already set by Set")
	}

	if mmCheckInventory.defaultExpectation == nil {
		mmCheckInventory.defaultExpectation = &ShopRepositoryMockCheckInventoryExpectation{}
	}

	if mmCheckInventory.defaultExpectation.paramPtrs != nil {
		mmCheckInventory.mock.t.Fatalf("ShopRepositoryMock.CheckInventory mock is already set by ExpectParams functions")
	}

	mmCheckInventory.defaultExpectation.params = &ShopRepositoryMockCheckInventoryParams{ctx, userID, item}
	mmCheckInventory.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckInventory.expectations {
		if minimock.Equal(e.params, mmCheckInventory.defaultExpectation.params) {
			mmCheckInventory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckInventory.defaultExpectation.params)
		}
	}

	return mmCheckInventory
}

// ExpectCtxParam1 sets up expected param ctx for ShopRepository.CheckInventory
func (mmCheckInventory *mShopRepositoryMockCheckInventory) ExpectCtxParam1(ctx context.Context) *mShopRepositoryMockCheckInventory {
	if mmCheckInventory.mock.funcCheckInventory != nil {
		mmCheckInventory.mock.t.Fatalf("ShopRepositoryMock.CheckInventory mock is already set by Set")
	}

	if mmCheckInventory.defaultExpectation == nil {
		mmCheckInventory.defaultExpectation = &ShopRepositoryMockCheckInventoryExpectation{}
	}

	if mmCheckInventory.defaultExpectation.params != nil {
		mmCheckInventory.mock.t.Fatalf("ShopRepositoryMock.CheckInventory mock is already set by Expect")
	}

	if mmCheckInventory.defaultExpectation.paramPtrs == nil {
		mmCheckInventory.defaultExpectation.paramPtrs = &ShopRepositoryMockCheckInventoryParamPtrs{}
	}
	mmCheckInventory.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckInventory.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckInventory
}

// ExpectUserIDParam2 sets up expected param userID for ShopRepository.CheckInventory
func (mmCheckInventory *mShopRepositoryMockCheckInventory) ExpectUserIDParam2(userID int64) *mShopRepositoryMockCheckInventory {
	if mmCheckInventory.mock.funcCheckInventory != nil {
		mmCheckInventory.mock.t.Fatalf("ShopRepositoryMock.CheckInventory mock is already set by Set")
	}

	if mmCheckInventory.defaultExpectation == nil {
		mmCheckInventory.defaultExpectation = &ShopRepositoryMockCheckInventoryExpectation{}
	}

	if mmCheckInventory.defaultExpectation.params != nil {
		mmCheckInventory.mock.t.Fatalf("ShopRepositoryMock.CheckInventory mock is already set by Expect")
	}

	if mmCheckInventory.defaultExpectation.paramPtrs == nil {
		mmCheckInventory.defaultExpectation.paramPtrs = &ShopRepositoryMockCheckInventoryParamPtrs{}
	}
	mmCheckInventory.defaultExpectation.paramPtrs.userID = &userID
	mmCheckInventory.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmCheckInventory
}

// ExpectItemParam3 sets up expected param item for ShopRepository.CheckInventory
func (mmCheckInventory *mShopRepositoryMockCheckInventory) ExpectItemParam3(item string) *mShopRepositoryMockCheckInventory {
	if mmCheckInventory.mock.funcCheckInventory != nil {
		mmCheckInventory.mock.t.Fatalf("ShopRepositoryMock.CheckInventory mock is already set by Set")
	}

	if mmCheckInventory.defaultExpectation == nil {
		mmCheckInventory.defaultExpectation = &ShopRepositoryMockCheckInventoryExpectation{}
	}

	if mmCheckInventory.defaultExpectation.params != nil {
		mmCheckInventory.mock.t.Fatalf("ShopRepositoryMock.CheckInventory mock is already set by Expect")
	}

	if mmCheckInventory.defaultExpectation.paramPtrs == nil {
		mmCheckInventory.defaultExpectation.paramPtrs = &ShopRepositoryMockCheckInventoryParamPtrs{}
	}
	mmCheckInventory.defaultExpectation.paramPtrs.item = &item
	mmCheckInventory.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmCheckInventory
}

// Inspect accepts an inspector function that has same arguments as the ShopRepository.CheckInventory
func (mmCheckInventory *mShopRepositoryMockCheckInventory) Inspect(f func(ctx context.Context, userID int64, item string)) *mShopRepositoryMockCheckInventory {
	if mmCheckInventory.mock.inspectFuncCheckInventory != nil {
		mmCheckInventory.mock.t.Fatalf("Inspect function is already set for ShopRepositoryMock.CheckInventory")
	}

	mmCheckInventory.mock.inspectFuncCheckInventory = f

	return mmCheckInventory
}

// Return sets up results that will be returned by ShopRepository.CheckInventory
func (mmCheckInventory *mShopRepositoryMockCheckInventory) Return(b1 bool, i1 int64, err error) *ShopRepositoryMock {
	if mmCheckInventory.mock.funcCheckInventory != nil {
		mmCheckInventory.mock.t.Fatalf("ShopRepositoryMock.CheckInventory mock is already set by Set")
	}

	if mmCheckInventory.defaultExpectation == nil {
		mmCheckInventory.defaultExpectation = &ShopRepositoryMockCheckInventoryExpectation{mock: mmCheckInventory.mock}
	}
	mmCheckInventory.defaultExpectation.results = &ShopRepositoryMockCheckInventoryResults{b1, i1, err}
	mmCheckInventory.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckInventory.mock
}

// Set uses given function f to mock the ShopRepository.CheckInventory method
func (mmCheckInventory *mShopRepositoryMockCheckInventory) Set(f func(ctx context.Context, userID int64, item string) (b1 bool, i1 int64, err error)) *ShopRepositoryMock {
	if mmCheckInventory.defaultExpectation != nil {
		mmCheckInventory.mock.t.Fatalf("Default expectation is already set for the ShopRepository.CheckInventory method")
	}

	if len(mmCheckInventory.expectations) > 0 {
		mmCheckInventory.mock.t.Fatalf("Some expectations are already set for the ShopRepository.CheckInventory method")
	}

	mmCheckInventory.mock.funcCheckInventory = f
	mmCheckInventory.mock.funcCheckInventoryOrigin = minimock.CallerInfo(1)
	return mmCheckInventory.mock
}

// When sets expectation for the ShopRepository.CheckInventory which will trigger the result defined by the following
// Then helper
func (mmCheckInventory *mShopRepositoryMockCheckInventory) When(ctx context.Context, userID int64, item string) *ShopRepositoryMockCheckInventoryExpectation {
	if mmCheckInventory.mock.funcCheckInventory != nil {
		mmCheckInventory.mock.t.Fatalf("ShopRepositoryMock.CheckInventory mock is already set by Set")
	}

	expectation := &ShopRepositoryMockCheckInventoryExpectation{
		mock:               mmCheckInventory.mock,
		params:             &ShopRepositoryMockCheckInventoryParams{ctx, userID, item},
		expectationOrigins: ShopRepositoryMockCheckInventoryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckInventory.expectations = append(mmCheckInventory.expectations, expectation)
	return expectation
}

// Then sets up ShopRepository.CheckInventory return parameters for the expectation previously defined by the When method
func (e *ShopRepositoryMockCheckInventoryExpectation) Then(b1 bool, i1 int64, err error) *ShopRepositoryMock {
	e.results = &ShopRepositoryMockCheckInventoryResults{b1, i1, err}
	return e.mock
}

// Times sets number of times ShopRepository.CheckInventory should be invoked
func (mmCheckInventory *mShopRepositoryMockCheckInventory) Times(n uint64) *mShopRepositoryMockCheckInventory {
	if n == 0 {
		mmCheckInventory.mock.t.Fatalf("Times of ShopRepositoryMock.CheckInventory mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckInventory.expectedInvocations, n)
	mmCheckInventory.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckInventory
}

func (mmCheckInventory *mShopRepositoryMockCheckInventory) invocationsDone() bool {
	if len(mmCheckInventory.expectations) == 0 && mmCheckInventory.defaultExpectation == nil && mmCheckInventory.mock.funcCheckInventory == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckInventory.mock.afterCheckInventoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckInventory.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckInventory implements mm_repository.ShopRepository
func (mmCheckInventory *ShopRepositoryMock) CheckInventory(ctx context.Context, userID int64, item string) (b1 bool, i1 int64, err error) {
	mm_atomic.AddUint64(&mmCheckInventory.beforeCheckInventoryCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckInventory.afterCheckInventoryCounter, 1)

	mmCheckInventory.t.Helper()

	if mmCheckInventory.inspectFuncCheckInventory != nil {
		mmCheckInventory.inspectFuncCheckInventory(ctx, userID, item)
	}

	mm_params := ShopRepositoryMockCheckInventoryParams{ctx, userID, item}

	// Record call args
	mmCheckInventory.CheckInventoryMock.mutex.Lock()
	mmCheckInventory.CheckInventoryMock.callArgs = append(mmCheckInventory.CheckInventoryMock.callArgs, &mm_params)
	mmCheckInventory.CheckInventoryMock.mutex.Unlock()

	for _, e := range mmCheckInventory.CheckInventoryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.i1, e.results.err
		}
	}

	if mmCheckInventory.CheckInventoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckInventory.CheckInventoryMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckInventory.CheckInventoryMock.defaultExpectation.params
		mm_want_ptrs := mmCheckInventory.CheckInventoryMock.defaultExpectation.paramPtrs

		mm_got := ShopRepositoryMockCheckInventoryParams{ctx, userID, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckInventory.t.Errorf("ShopRepositoryMock.CheckInventory got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckInventory.CheckInventoryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmCheckInventory.t.Errorf("ShopRepositoryMock.CheckInventory got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckInventory.CheckInventoryMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmCheckInventory.t.Errorf("ShopRepositoryMock.CheckInventory got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckInventory.CheckInventoryMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckInventory.t.Errorf("ShopRepositoryMock.CheckInventory got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckInventory.CheckInventoryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckInventory.CheckInventoryMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckInventory.t.Fatal("No results are set for the ShopRepositoryMock.CheckInventory")
		}
		return (*mm_results).b1, (*mm_results).i1, (*mm_results).err
	}
	if mmCheckInventory.funcCheckInventory != nil {
		return mmCheckInventory.funcCheckInventory(ctx, userID, item)
	}
	mmCheckInventory.t.Fatalf("Unexpected call to ShopRepositoryMock.CheckInventory. %v %v %v", ctx, userID, item)
	return
}

// CheckInventoryAfterCounter returns a count of finished ShopRepositoryMock.CheckInventory invocations
func (mmCheckInventory *ShopRepositoryMock) CheckInventoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckInventory.afterCheckInventoryCounter)
}

// CheckInventoryBeforeCounter returns a count of ShopRepositoryMock.CheckInventory invocations
func (mmCheckInventory *ShopRepositoryMock) CheckInventoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckInventory.beforeCheckInventoryCounter)
}

// Calls returns a list of arguments used in each call to ShopRepositoryMock.CheckInventory.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckInventory *mShopRepositoryMockCheckInventory) Calls() []*ShopRepositoryMockCheckInventoryParams {
	mmCheckInventory.mutex.RLock()

	argCopy := make([]*ShopRepositoryMockCheckInventoryParams, len(mmCheckInventory.callArgs))
	copy(argCopy, mmCheckInventory.callArgs)

	mmCheckInventory.mutex.RUnlock()

	return argCopy
}

// MinimockCheckInventoryDone returns true if the count of the CheckInventory invocations corresponds
// the number of defined expectations
func (m *ShopRepositoryMock) MinimockCheckInventoryDone() bool {
	if m.CheckInventoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckInventoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckInventoryMock.invocationsDone()
}

// MinimockCheckInventoryInspect logs each unmet expectation
func (m *ShopRepositoryMock) MinimockCheckInventoryInspect() {
	for _, e := range m.CheckInventoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ShopRepositoryMock.CheckInventory at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckInventoryCounter := mm_atomic.LoadUint64(&m.afterCheckInventoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckInventoryMock.defaultExpectation != nil && afterCheckInventoryCounter < 1 {
		if m.CheckInventoryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ShopRepositoryMock.CheckInventory at\n%s", m.CheckInventoryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ShopRepositoryMock.CheckInventory at\n%s with params: %#v", m.CheckInventoryMock.defaultExpectation.expectationOrigins.origin, *m.CheckInventoryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckInventory != nil && afterCheckInventoryCounter < 1 {
		m.t.Errorf("Expected call to ShopRepositoryMock.CheckInventory at\n%s", m.funcCheckInventoryOrigin)
	}

	if !m.CheckInventoryMock.invocationsDone() && afterCheckInventoryCounter > 0 {
		m.t.Errorf("Expected %d calls to ShopRepositoryMock.CheckInventory at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckInventoryMock.expectedInvocations), m.CheckInventoryMock.expectedInvocationsOrigin, afterCheckInventoryCounter)
	}
}

type mShopRepositoryMockCreateTransaction struct {
	optional           bool
	mock               *ShopRepositoryMock
	defaultExpectation *ShopRepositoryMockCreateTransactionExpectation
	expectations       []*ShopRepositoryMockCreateTransactionExpectation

	callArgs []*ShopRepositoryMockCreateTransactionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ShopRepositoryMockCreateTransactionExpectation specifies expectation struct of the ShopRepository.CreateTransaction
type ShopRepositoryMockCreateTransactionExpectation struct {
	mock               *ShopRepositoryMock
	params             *ShopRepositoryMockCreateTransactionParams
	paramPtrs          *ShopRepositoryMockCreateTransactionParamPtrs
	expectationOrigins ShopRepositoryMockCreateTransactionExpectationOrigins
	results            *ShopRepositoryMockCreateTransactionResults
	returnOrigin       string
	Counter            uint64
}

// ShopRepositoryMockCreateTransactionParams contains parameters of the ShopRepository.CreateTransaction
type ShopRepositoryMockCreateTransactionParams struct {
	ctx        context.Context
	fromUserID int64
	toUserID   int64
	amount     int64
}

// ShopRepositoryMockCreateTransactionParamPtrs contains pointers to parameters of the ShopRepository.CreateTransaction
type ShopRepositoryMockCreateTransactionParamPtrs struct {
	ctx        *context.Context
	fromUserID *int64
	toUserID   *int64
	amount     *int64
}

// ShopRepositoryMockCreateTransactionResults contains results of the ShopRepository.CreateTransaction
type ShopRepositoryMockCreateTransactionResults struct {
	err error
}

// ShopRepositoryMockCreateTransactionOrigins contains origins of expectations of the ShopRepository.CreateTransaction
type ShopRepositoryMockCreateTransactionExpectationOrigins struct {
	origin           string
	originCtx        string
	originFromUserID string
	originToUserID   string
	originAmount     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateTransaction *mShopRepositoryMockCreateTransaction) Optional() *mShopRepositoryMockCreateTransaction {
	mmCreateTransaction.optional = true
	return mmCreateTransaction
}

// Expect sets up expected params for ShopRepository.CreateTransaction
func (mmCreateTransaction *mShopRepositoryMockCreateTransaction) Expect(ctx context.Context, fromUserID int64, toUserID int64, amount int64) *mShopRepositoryMockCreateTransaction {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("ShopRepositoryMock.CreateTransaction mock is already set by Set")
	}

	if mmCreateTransaction.defaultExpectation == nil {
		mmCreateTransaction.defaultExpectation = &ShopRepositoryMockCreateTransactionExpectation{}
	}

	if mmCreateTransaction.defaultExpectation.paramPtrs != nil {
		mmCreateTransaction.mock.t.Fatalf("ShopRepositoryMock.CreateTransaction mock is already set by ExpectParams functions")
	}

	mmCreateTransaction.defaultExpectation.params = &ShopRepositoryMockCreateTransactionParams{ctx, fromUserID, toUserID, amount}
	mmCreateTransaction.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateTransaction.expectations {
		if minimock.Equal(e.params, mmCreateTransaction.defaultExpectation.params) {
			mmCreateTransaction.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateTransaction.defaultExpectation.params)
		}
	}

	return mmCreateTransaction
}

// ExpectCtxParam1 sets up expected param ctx for ShopRepository.CreateTransaction
func (mmCreateTransaction *mShopRepositoryMockCreateTransaction) ExpectCtxParam1(ctx context.Context) *mShopRepositoryMockCreateTransaction {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("ShopRepositoryMock.CreateTransaction mock is already set by Set")
	}

	if mmCreateTransaction.defaultExpectation == nil {
		mmCreateTransaction.defaultExpectation = &ShopRepositoryMockCreateTransactionExpectation{}
	}

	if mmCreateTransaction.defaultExpectation.params != nil {
		mmCreateTransaction.mock.t.Fatalf("ShopRepositoryMock.CreateTransaction mock is already set by Expect")
	}

	if mmCreateTransaction.defaultExpectation.paramPtrs == nil {
		mmCreateTransaction.defaultExpectation.paramPtrs = &ShopRepositoryMockCreateTransactionParamPtrs{}
	}
	mmCreateTransaction.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateTransaction.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateTransaction
}

// ExpectFromUserIDParam2 sets up expected param fromUserID for ShopRepository.CreateTransaction
func (mmCreateTransaction *mShopRepositoryMockCreateTransaction) ExpectFromUserIDParam2(fromUserID int64) *mShopRepositoryMockCreateTransaction {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("ShopRepositoryMock.CreateTransaction mock is already set by Set")
	}

	if mmCreateTransaction.defaultExpectation == nil {
		mmCreateTransaction.defaultExpectation = &ShopRepositoryMockCreateTransactionExpectation{}
	}

	if mmCreateTransaction.defaultExpectation.params != nil {
		mmCreateTransaction.mock.t.Fatalf("ShopRepositoryMock.CreateTransaction mock is already set by Expect")
	}

	if mmCreateTransaction.defaultExpectation.paramPtrs == nil {
		mmCreateTransaction.defaultExpectation.paramPtrs = &ShopRepositoryMockCreateTransactionParamPtrs{}
	}
	mmCreateTransaction.defaultExpectation.paramPtrs.fromUserID = &fromUserID
	mmCreateTransaction.defaultExpectation.expectationOrigins.originFromUserID = minimock.CallerInfo(1)

	return mmCreateTransaction
}

// ExpectToUserIDParam3 sets up expected param toUserID for ShopRepository.CreateTransaction
func (mmCreateTransaction *mShopRepositoryMockCreateTransaction) ExpectToUserIDParam3(toUserID int64) *mShopRepositoryMockCreateTransaction {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("ShopRepositoryMock.CreateTransaction mock is already set by Set")
	}

	if mmCreateTransaction.defaultExpectation == nil {
		mmCreateTransaction.defaultExpectation = &ShopRepositoryMockCreateTransactionExpectation{}
	}

	if mmCreateTransaction.defaultExpectation.params != nil {
		mmCreateTransaction.mock.t.Fatalf("ShopRepositoryMock.CreateTransaction mock is already set by Expect")
	}

	if mmCreateTransaction.defaultExpectation.paramPtrs == nil {
		mmCreateTransaction.defaultExpectation.paramPtrs = &ShopRepositoryMockCreateTransactionParamPtrs{}
	}
	mmCreateTransaction.defaultExpectation.paramPtrs.toUserID = &toUserID
	mmCreateTransaction.defaultExpectation.expectationOrigins.originToUserID = minimock.CallerInfo(1)

	return mmCreateTransaction
}

// ExpectAmountParam4 sets up expected param amount for ShopRepository.CreateTransaction
func (mmCreateTransaction *mShopRepositoryMockCreateTransaction) ExpectAmountParam4(amount int64) *mShopRepositoryMockCreateTransaction {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("ShopRepositoryMock.CreateTransaction mock is already set by Set")
	}

	if mmCreateTransaction.defaultExpectation == nil {
		mmCreateTransaction.defaultExpectation = &ShopRepositoryMockCreateTransactionExpectation{}
	}

	if mmCreateTransaction.defaultExpectation.params != nil {
		mmCreateTransaction.mock.t.Fatalf("ShopRepositoryMock.CreateTransaction mock is already set by Expect")
	}

	if mmCreateTransaction.defaultExpectation.paramPtrs == nil {
		mmCreateTransaction.defaultExpectation.paramPtrs = &ShopRepositoryMockCreateTransactionParamPtrs{}
	}
	mmCreateTransaction.defaultExpectation.paramPtrs.amount = &amount
	mmCreateTransaction.defaultExpectation.expectationOrigins.originAmount = minimock.CallerInfo(1)

	return mmCreateTransaction
}

// Inspect accepts an inspector function that has same arguments as the ShopRepository.CreateTransaction
func (mmCreateTransaction *mShopRepositoryMockCreateTransaction) Inspect(f func(ctx context.Context, fromUserID int64, toUserID int64, amount int64)) *mShopRepositoryMockCreateTransaction {
	if mmCreateTransaction.mock.inspectFuncCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("Inspect function is already set for ShopRepositoryMock.CreateTransaction")
	}

	mmCreateTransaction.mock.inspectFuncCreateTransaction = f

	return mmCreateTransaction
}

// Return sets up results that will be returned by ShopRepository.CreateTransaction
func (mmCreateTransaction *mShopRepositoryMockCreateTransaction) Return(err error) *ShopRepositoryMock {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("ShopRepositoryMock.CreateTransaction mock is already set by Set")
	}

	if mmCreateTransaction.defaultExpectation == nil {
		mmCreateTransaction.defaultExpectation = &ShopRepositoryMockCreateTransactionExpectation{mock: mmCreateTransaction.mock}
	}
	mmCreateTransaction.defaultExpectation.results = &ShopRepositoryMockCreateTransactionResults{err}
	mmCreateTransaction.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateTransaction.mock
}

// Set uses given function f to mock the ShopRepository.CreateTransaction method
func (mmCreateTransaction *mShopRepositoryMockCreateTransaction) Set(f func(ctx context.Context, fromUserID int64, toUserID int64, amount int64) (err error)) *ShopRepositoryMock {
	if mmCreateTransaction.defaultExpectation != nil {
		mmCreateTransaction.mock.t.Fatalf("Default expectation is already set for the ShopRepository.CreateTransaction method")
	}

	if len(mmCreateTransaction.expectations) > 0 {
		mmCreateTransaction.mock.t.Fatalf("Some expectations are already set for the ShopRepository.CreateTransaction method")
	}

	mmCreateTransaction.mock.funcCreateTransaction = f
	mmCreateTransaction.mock.funcCreateTransactionOrigin = minimock.CallerInfo(1)
	return mmCreateTransaction.mock
}

// When sets expectation for the ShopRepository.CreateTransaction which will trigger the result defined by the following
// Then helper
func (mmCreateTransaction *mShopRepositoryMockCreateTransaction) When(ctx context.Context, fromUserID int64, toUserID int64, amount int64) *ShopRepositoryMockCreateTransactionExpectation {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("ShopRepositoryMock.CreateTransaction mock is already set by Set")
	}

	expectation := &ShopRepositoryMockCreateTransactionExpectation{
		mock:               mmCreateTransaction.mock,
		params:             &ShopRepositoryMockCreateTransactionParams{ctx, fromUserID, toUserID, amount},
		expectationOrigins: ShopRepositoryMockCreateTransactionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateTransaction.expectations = append(mmCreateTransaction.expectations, expectation)
	return expectation
}

// Then sets up ShopRepository.CreateTransaction return parameters for the expectation previously defined by the When method
func (e *ShopRepositoryMockCreateTransactionExpectation) Then(err error) *ShopRepositoryMock {
	e.results = &ShopRepositoryMockCreateTransactionResults{err}
	return e.mock
}

// Times sets number of times ShopRepository.CreateTransaction should be invoked
func (mmCreateTransaction *mShopRepositoryMockCreateTransaction) Times(n uint64) *mShopRepositoryMockCreateTransaction {
	if n == 0 {
		mmCreateTransaction.mock.t.Fatalf("Times of ShopRepositoryMock.CreateTransaction mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateTransaction.expectedInvocations, n)
	mmCreateTransaction.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateTransaction
}

func (mmCreateTransaction *mShopRepositoryMockCreateTransaction) invocationsDone() bool {
	if len(mmCreateTransaction.expectations) == 0 && mmCreateTransaction.defaultExpectation == nil && mmCreateTransaction.mock.funcCreateTransaction == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateTransaction.mock.afterCreateTransactionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateTransaction.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateTransaction implements mm_repository.ShopRepository
func (mmCreateTransaction *ShopRepositoryMock) CreateTransaction(ctx context.Context, fromUserID int64, toUserID int64, amount int64) (err error) {
	mm_atomic.AddUint64(&mmCreateTransaction.beforeCreateTransactionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateTransaction.afterCreateTransactionCounter, 1)

	mmCreateTransaction.t.Helper()

	if mmCreateTransaction.inspectFuncCreateTransaction != nil {
		mmCreateTransaction.inspectFuncCreateTransaction(ctx, fromUserID, toUserID, amount)
	}

	mm_params := ShopRepositoryMockCreateTransactionParams{ctx, fromUserID, toUserID, amount}

	// Record call args
	mmCreateTransaction.CreateTransactionMock.mutex.Lock()
	mmCreateTransaction.CreateTransactionMock.callArgs = append(mmCreateTransaction.CreateTransactionMock.callArgs, &mm_params)
	mmCreateTransaction.CreateTransactionMock.mutex.Unlock()

	for _, e := range mmCreateTransaction.CreateTransactionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateTransaction.CreateTransactionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateTransaction.CreateTransactionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateTransaction.CreateTransactionMock.defaultExpectation.params
		mm_want_ptrs := mmCreateTransaction.CreateTransactionMock.defaultExpectation.paramPtrs

		mm_got := ShopRepositoryMockCreateTransactionParams{ctx, fromUserID, toUserID, amount}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateTransaction.t.Errorf("ShopRepositoryMock.CreateTransaction got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTransaction.CreateTransactionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fromUserID != nil && !minimock.Equal(*mm_want_ptrs.fromUserID, mm_got.fromUserID) {
				mmCreateTransaction.t.Errorf("ShopRepositoryMock.CreateTransaction got unexpected parameter fromUserID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTransaction.CreateTransactionMock.defaultExpectation.expectationOrigins.originFromUserID, *mm_want_ptrs.fromUserID, mm_got.fromUserID, minimock.Diff(*mm_want_ptrs.fromUserID, mm_got.fromUserID))
			}

			if mm_want_ptrs.toUserID != nil && !minimock.Equal(*mm_want_ptrs.toUserID, mm_got.toUserID) {
				mmCreateTransaction.t.Errorf("ShopRepositoryMock.CreateTransaction got unexpected parameter toUserID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTransaction.CreateTransactionMock.defaultExpectation.expectationOrigins.originToUserID, *mm_want_ptrs.toUserID, mm_got.toUserID, minimock.Diff(*mm_want_ptrs.toUserID, mm_got.toUserID))
			}

			if mm_want_ptrs.amount != nil && !minimock.Equal(*mm_want_ptrs.amount, mm_got.amount) {
				mmCreateTransaction.t.Errorf("ShopRepositoryMock.CreateTransaction got unexpected parameter amount, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTransaction.CreateTransactionMock.defaultExpectation.expectationOrigins.originAmount, *mm_want_ptrs.amount, mm_got.amount, minimock.Diff(*mm_want_ptrs.amount, mm_got.amount))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateTransaction.t.Errorf("ShopRepositoryMock.CreateTransaction got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateTransaction.CreateTransactionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateTransaction.CreateTransactionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateTransaction.t.Fatal("No results are set for the ShopRepositoryMock.CreateTransaction")
		}
		return (*mm_results).err
	}
	if mmCreateTransaction.funcCreateTransaction != nil {
		return mmCreateTransaction.funcCreateTransaction(ctx, fromUserID, toUserID, amount)
	}
	mmCreateTransaction.t.Fatalf("Unexpected call to ShopRepositoryMock.CreateTransaction. %v %v %v %v", ctx, fromUserID, toUserID, amount)
	return
}

// CreateTransactionAfterCounter returns a count of finished ShopRepositoryMock.CreateTransaction invocations
func (mmCreateTransaction *ShopRepositoryMock) CreateTransactionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTransaction.afterCreateTransactionCounter)
}

// CreateTransactionBeforeCounter returns a count of ShopRepositoryMock.CreateTransaction invocations
func (mmCreateTransaction *ShopRepositoryMock) CreateTransactionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTransaction.beforeCreateTransactionCounter)
}

// Calls returns a list of arguments used in each call to ShopRepositoryMock.CreateTransaction.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateTransaction *mShopRepositoryMockCreateTransaction) Calls() []*ShopRepositoryMockCreateTransactionParams {
	mmCreateTransaction.mutex.RLock()

	argCopy := make([]*ShopRepositoryMockCreateTransactionParams, len(mmCreateTransaction.callArgs))
	copy(argCopy, mmCreateTransaction.callArgs)

	mmCreateTransaction.mutex.RUnlock()

	return argCopy
}

// MinimockCreateTransactionDone returns true if the count of the CreateTransaction invocations corresponds
// the number of defined expectations
func (m *ShopRepositoryMock) MinimockCreateTransactionDone() bool {
	if m.CreateTransactionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateTransactionMock.invocationsDone()
}

// MinimockCreateTransactionInspect logs each unmet expectation
func (m *ShopRepositoryMock) MinimockCreateTransactionInspect() {
	for _, e := range m.CreateTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ShopRepositoryMock.CreateTransaction at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateTransactionCounter := mm_atomic.LoadUint64(&m.afterCreateTransactionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTransactionMock.defaultExpectation != nil && afterCreateTransactionCounter < 1 {
		if m.CreateTransactionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ShopRepositoryMock.CreateTransaction at\n%s", m.CreateTransactionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ShopRepositoryMock.CreateTransaction at\n%s with params: %#v", m.CreateTransactionMock.defaultExpectation.expectationOrigins.origin, *m.CreateTransactionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTransaction != nil && afterCreateTransactionCounter < 1 {
		m.t.Errorf("Expected call to ShopRepositoryMock.CreateTransaction at\n%s", m.funcCreateTransactionOrigin)
	}

	if !m.CreateTransactionMock.invocationsDone() && afterCreateTransactionCounter > 0 {
		m.t.Errorf("Expected %d calls to ShopRepositoryMock.CreateTransaction at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateTransactionMock.expectedInvocations), m.CreateTransactionMock.expectedInvocationsOrigin, afterCreateTransactionCounter)
	}
}

type mShopRepositoryMockGetMerchPrice struct {
	optional           bool
	mock               *ShopRepositoryMock
	defaultExpectation *ShopRepositoryMockGetMerchPriceExpectation
	expectations       []*ShopRepositoryMockGetMerchPriceExpectation

	callArgs []*ShopRepositoryMockGetMerchPriceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ShopRepositoryMockGetMerchPriceExpectation specifies expectation struct of the ShopRepository.GetMerchPrice
type ShopRepositoryMockGetMerchPriceExpectation struct {
	mock               *ShopRepositoryMock
	params             *ShopRepositoryMockGetMerchPriceParams
	paramPtrs          *ShopRepositoryMockGetMerchPriceParamPtrs
	expectationOrigins ShopRepositoryMockGetMerchPriceExpectationOrigins
	results            *ShopRepositoryMockGetMerchPriceResults
	returnOrigin       string
	Counter            uint64
}

// ShopRepositoryMockGetMerchPriceParams contains parameters of the ShopRepository.GetMerchPrice
type ShopRepositoryMockGetMerchPriceParams struct {
	ctx  context.Context
	item string
}

// ShopRepositoryMockGetMerchPriceParamPtrs contains pointers to parameters of the ShopRepository.GetMerchPrice
type ShopRepositoryMockGetMerchPriceParamPtrs struct {
	ctx  *context.Context
	item *string
}

// ShopRepositoryMockGetMerchPriceResults contains results of the ShopRepository.GetMerchPrice
type ShopRepositoryMockGetMerchPriceResults struct {
	i1  int64
	err error
}

// ShopRepositoryMockGetMerchPriceOrigins contains origins of expectations of the ShopRepository.GetMerchPrice
type ShopRepositoryMockGetMerchPriceExpectationOrigins struct {
	origin     string
	originCtx  string
	originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetMerchPrice *mShopRepositoryMockGetMerchPrice) Optional() *mShopRepositoryMockGetMerchPrice {
	mmGetMerchPrice.optional = true
	return mmGetMerchPrice
}

// Expect sets up expected params for ShopRepository.GetMerchPrice
func (mmGetMerchPrice *mShopRepositoryMockGetMerchPrice) Expect(ctx context.Context, item string) *mShopRepositoryMockGetMerchPrice {
	if mmGetMerchPrice.mock.funcGetMerchPrice != nil {
		mmGetMerchPrice.mock.t.Fatalf("ShopRepositoryMock.GetMerchPrice mock is already set by Set")
	}

	if mmGetMerchPrice.defaultExpectation == nil {
		mmGetMerchPrice.defaultExpectation = &ShopRepositoryMockGetMerchPriceExpectation{}
	}

	if mmGetMerchPrice.defaultExpectation.paramPtrs != nil {
		mmGetMerchPrice.mock.t.Fatalf("ShopRepositoryMock.GetMerchPrice mock is already set by ExpectParams functions")
	}

	mmGetMerchPrice.defaultExpectation.params = &ShopRepositoryMockGetMerchPriceParams{ctx, item}
	mmGetMerchPrice.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetMerchPrice.expectations {
		if minimock.Equal(e.params, mmGetMerchPrice.defaultExpectation.params) {
			mmGetMerchPrice.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetMerchPrice.defaultExpectation.params)
		}
	}

	return mmGetMerchPrice
}

// ExpectCtxParam1 sets up expected param ctx for ShopRepository.GetMerchPrice
func (mmGetMerchPrice *mShopRepositoryMockGetMerchPrice) ExpectCtxParam1(ctx context.Context) *mShopRepositoryMockGetMerchPrice {
	if mmGetMerchPrice.mock.funcGetMerchPrice != nil {
		mmGetMerchPrice.mock.t.Fatalf("ShopRepositoryMock.GetMerchPrice mock is already set by Set")
	}

	if mmGetMerchPrice.defaultExpectation == nil {
		mmGetMerchPrice.defaultExpectation = &ShopRepositoryMockGetMerchPriceExpectation{}
	}

	if mmGetMerchPrice.defaultExpectation.params != nil {
		mmGetMerchPrice.mock.t.Fatalf("ShopRepositoryMock.GetMerchPrice mock is already set by Expect")
	}

	if mmGetMerchPrice.defaultExpectation.paramPtrs == nil {
		mmGetMerchPrice.defaultExpectation.paramPtrs = &ShopRepositoryMockGetMerchPriceParamPtrs{}
	}
	mmGetMerchPrice.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetMerchPrice.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetMerchPrice
}

// ExpectItemParam2 sets up expected param item for ShopRepository.GetMerchPrice
func (mmGetMerchPrice *mShopRepositoryMockGetMerchPrice) ExpectItemParam2(item string) *mShopRepositoryMockGetMerchPrice {
	if mmGetMerchPrice.mock.funcGetMerchPrice != nil {
		mmGetMerchPrice.mock.t.Fatalf("ShopRepositoryMock.GetMerchPrice mock is already set by Set")
	}

	if mmGetMerchPrice.defaultExpectation == nil {
		mmGetMerchPrice.defaultExpectation = &ShopRepositoryMockGetMerchPriceExpectation{}
	}

	if mmGetMerchPrice.defaultExpectation.params != nil {
		mmGetMerchPrice.mock.t.Fatalf("ShopRepositoryMock.GetMerchPrice mock is already set by Expect")
	}

	if mmGetMerchPrice.defaultExpectation.paramPtrs == nil {
		mmGetMerchPrice.defaultExpectation.paramPtrs = &ShopRepositoryMockGetMerchPriceParamPtrs{}
	}
	mmGetMerchPrice.defaultExpectation.paramPtrs.item = &item
	mmGetMerchPrice.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmGetMerchPrice
}

// Inspect accepts an inspector function that has same arguments as the ShopRepository.GetMerchPrice
func (mmGetMerchPrice *mShopRepositoryMockGetMerchPrice) Inspect(f func(ctx context.Context, item string)) *mShopRepositoryMockGetMerchPrice {
	if mmGetMerchPrice.mock.inspectFuncGetMerchPrice != nil {
		mmGetMerchPrice.mock.t.Fatalf("Inspect function is already set for ShopRepositoryMock.GetMerchPrice")
	}

	mmGetMerchPrice.mock.inspectFuncGetMerchPrice = f

	return mmGetMerchPrice
}

// Return sets up results that will be returned by ShopRepository.GetMerchPrice
func (mmGetMerchPrice *mShopRepositoryMockGetMerchPrice) Return(i1 int64, err error) *ShopRepositoryMock {
	if mmGetMerchPrice.mock.funcGetMerchPrice != nil {
		mmGetMerchPrice.mock.t.Fatalf("ShopRepositoryMock.GetMerchPrice mock is already set by Set")
	}

	if mmGetMerchPrice.defaultExpectation == nil {
		mmGetMerchPrice.defaultExpectation = &ShopRepositoryMockGetMerchPriceExpectation{mock: mmGetMerchPrice.mock}
	}
	mmGetMerchPrice.defaultExpectation.results = &ShopRepositoryMockGetMerchPriceResults{i1, err}
	mmGetMerchPrice.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetMerchPrice.mock
}

// Set uses given function f to mock the ShopRepository.GetMerchPrice method
func (mmGetMerchPrice *mShopRepositoryMockGetMerchPrice) Set(f func(ctx context.Context, item string) (i1 int64, err error)) *ShopRepositoryMock {
	if mmGetMerchPrice.defaultExpectation != nil {
		mmGetMerchPrice.mock.t.Fatalf("Default expectation is already set for the ShopRepository.GetMerchPrice method")
	}

	if len(mmGetMerchPrice.expectations) > 0 {
		mmGetMerchPrice.mock.t.Fatalf("Some expectations are already set for the ShopRepository.GetMerchPrice method")
	}

	mmGetMerchPrice.mock.funcGetMerchPrice = f
	mmGetMerchPrice.mock.funcGetMerchPriceOrigin = minimock.CallerInfo(1)
	return mmGetMerchPrice.mock
}

// When sets expectation for the ShopRepository.GetMerchPrice which will trigger the result defined by the following
// Then helper
func (mmGetMerchPrice *mShopRepositoryMockGetMerchPrice) When(ctx context.Context, item string) *ShopRepositoryMockGetMerchPriceExpectation {
	if mmGetMerchPrice.mock.funcGetMerchPrice != nil {
		mmGetMerchPrice.mock.t.Fatalf("ShopRepositoryMock.GetMerchPrice mock is already set by Set")
	}

	expectation := &ShopRepositoryMockGetMerchPriceExpectation{
		mock:               mmGetMerchPrice.mock,
		params:             &ShopRepositoryMockGetMerchPriceParams{ctx, item},
		expectationOrigins: ShopRepositoryMockGetMerchPriceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetMerchPrice.expectations = append(mmGetMerchPrice.expectations, expectation)
	return expectation
}

// Then sets up ShopRepository.GetMerchPrice return parameters for the expectation previously defined by the When method
func (e *ShopRepositoryMockGetMerchPriceExpectation) Then(i1 int64, err error) *ShopRepositoryMock {
	e.results = &ShopRepositoryMockGetMerchPriceResults{i1, err}
	return e.mock
}

// Times sets number of times ShopRepository.GetMerchPrice should be invoked
func (mmGetMerchPrice *mShopRepositoryMockGetMerchPrice) Times(n uint64) *mShopRepositoryMockGetMerchPrice {
	if n == 0 {
		mmGetMerchPrice.mock.t.Fatalf("Times of ShopRepositoryMock.GetMerchPrice mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetMerchPrice.expectedInvocations, n)
	mmGetMerchPrice.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetMerchPrice
}

func (mmGetMerchPrice *mShopRepositoryMockGetMerchPrice) invocationsDone() bool {
	if len(mmGetMerchPrice.expectations) == 0 && mmGetMerchPrice.defaultExpectation == nil && mmGetMerchPrice.mock.funcGetMerchPrice == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetMerchPrice.mock.afterGetMerchPriceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetMerchPrice.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetMerchPrice implements mm_repository.ShopRepository
func (mmGetMerchPrice *ShopRepositoryMock) GetMerchPrice(ctx context.Context, item string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetMerchPrice.beforeGetMerchPriceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetMerchPrice.afterGetMerchPriceCounter, 1)

	mmGetMerchPrice.t.Helper()

	if mmGetMerchPrice.inspectFuncGetMerchPrice != nil {
		mmGetMerchPrice.inspectFuncGetMerchPrice(ctx, item)
	}

	mm_params := ShopRepositoryMockGetMerchPriceParams{ctx, item}

	// Record call args
	mmGetMerchPrice.GetMerchPriceMock.mutex.Lock()
	mmGetMerchPrice.GetMerchPriceMock.callArgs = append(mmGetMerchPrice.GetMerchPriceMock.callArgs, &mm_params)
	mmGetMerchPrice.GetMerchPriceMock.mutex.Unlock()

	for _, e := range mmGetMerchPrice.GetMerchPriceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetMerchPrice.GetMerchPriceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMerchPrice.GetMerchPriceMock.defaultExpectation.Counter, 1)
		mm_want := mmGetMerchPrice.GetMerchPriceMock.defaultExpectation.params
		mm_want_ptrs := mmGetMerchPrice.GetMerchPriceMock.defaultExpectation.paramPtrs

		mm_got := ShopRepositoryMockGetMerchPriceParams{ctx, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetMerchPrice.t.Errorf("ShopRepositoryMock.GetMerchPrice got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetMerchPrice.GetMerchPriceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmGetMerchPrice.t.Errorf("ShopRepositoryMock.GetMerchPrice got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetMerchPrice.GetMerchPriceMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetMerchPrice.t.Errorf("ShopRepositoryMock.GetMerchPrice got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetMerchPrice.GetMerchPriceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetMerchPrice.GetMerchPriceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetMerchPrice.t.Fatal("No results are set for the ShopRepositoryMock.GetMerchPrice")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetMerchPrice.funcGetMerchPrice != nil {
		return mmGetMerchPrice.funcGetMerchPrice(ctx, item)
	}
	mmGetMerchPrice.t.Fatalf("Unexpected call to ShopRepositoryMock.GetMerchPrice. %v %v", ctx, item)
	return
}

// GetMerchPriceAfterCounter returns a count of finished ShopRepositoryMock.GetMerchPrice invocations
func (mmGetMerchPrice *ShopRepositoryMock) GetMerchPriceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMerchPrice.afterGetMerchPriceCounter)
}

// GetMerchPriceBeforeCounter returns a count of ShopRepositoryMock.GetMerchPrice invocations
func (mmGetMerchPrice *ShopRepositoryMock) GetMerchPriceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMerchPrice.beforeGetMerchPriceCounter)
}

// Calls returns a list of arguments used in each call to ShopRepositoryMock.GetMerchPrice.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetMerchPrice *mShopRepositoryMockGetMerchPrice) Calls() []*ShopRepositoryMockGetMerchPriceParams {
	mmGetMerchPrice.mutex.RLock()

	argCopy := make([]*ShopRepositoryMockGetMerchPriceParams, len(mmGetMerchPrice.callArgs))
	copy(argCopy, mmGetMerchPrice.callArgs)

	mmGetMerchPrice.mutex.RUnlock()

	return argCopy
}

// MinimockGetMerchPriceDone returns true if the count of the GetMerchPrice invocations corresponds
// the number of defined expectations
func (m *ShopRepositoryMock) MinimockGetMerchPriceDone() bool {
	if m.GetMerchPriceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMerchPriceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMerchPriceMock.invocationsDone()
}

// MinimockGetMerchPriceInspect logs each unmet expectation
func (m *ShopRepositoryMock) MinimockGetMerchPriceInspect() {
	for _, e := range m.GetMerchPriceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ShopRepositoryMock.GetMerchPrice at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetMerchPriceCounter := mm_atomic.LoadUint64(&m.afterGetMerchPriceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMerchPriceMock.defaultExpectation != nil && afterGetMerchPriceCounter < 1 {
		if m.GetMerchPriceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ShopRepositoryMock.GetMerchPrice at\n%s", m.GetMerchPriceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ShopRepositoryMock.GetMerchPrice at\n%s with params: %#v", m.GetMerchPriceMock.defaultExpectation.expectationOrigins.origin, *m.GetMerchPriceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMerchPrice != nil && afterGetMerchPriceCounter < 1 {
		m.t.Errorf("Expected call to ShopRepositoryMock.GetMerchPrice at\n%s", m.funcGetMerchPriceOrigin)
	}

	if !m.GetMerchPriceMock.invocationsDone() && afterGetMerchPriceCounter > 0 {
		m.t.Errorf("Expected %d calls to ShopRepositoryMock.GetMerchPrice at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMerchPriceMock.expectedInvocations), m.GetMerchPriceMock.expectedInvocationsOrigin, afterGetMerchPriceCounter)
	}
}

type mShopRepositoryMockGetUserInventory struct {
	optional           bool
	mock               *ShopRepositoryMock
	defaultExpectation *ShopRepositoryMockGetUserInventoryExpectation
	expectations       []*ShopRepositoryMockGetUserInventoryExpectation

	callArgs []*ShopRepositoryMockGetUserInventoryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ShopRepositoryMockGetUserInventoryExpectation specifies expectation struct of the ShopRepository.GetUserInventory
type ShopRepositoryMockGetUserInventoryExpectation struct {
	mock               *ShopRepositoryMock
	params             *ShopRepositoryMockGetUserInventoryParams
	paramPtrs          *ShopRepositoryMockGetUserInventoryParamPtrs
	expectationOrigins ShopRepositoryMockGetUserInventoryExpectationOrigins
	results            *ShopRepositoryMockGetUserInventoryResults
	returnOrigin       string
	Counter            uint64
}

// ShopRepositoryMockGetUserInventoryParams contains parameters of the ShopRepository.GetUserInventory
type ShopRepositoryMockGetUserInventoryParams struct {
	ctx    context.Context
	userID int64
}

// ShopRepositoryMockGetUserInventoryParamPtrs contains pointers to parameters of the ShopRepository.GetUserInventory
type ShopRepositoryMockGetUserInventoryParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// ShopRepositoryMockGetUserInventoryResults contains results of the ShopRepository.GetUserInventory
type ShopRepositoryMockGetUserInventoryResults struct {
	ia1 []model.InventoryItem
	err error
}

// ShopRepositoryMockGetUserInventoryOrigins contains origins of expectations of the ShopRepository.GetUserInventory
type ShopRepositoryMockGetUserInventoryExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserInventory *mShopRepositoryMockGetUserInventory) Optional() *mShopRepositoryMockGetUserInventory {
	mmGetUserInventory.optional = true
	return mmGetUserInventory
}

// Expect sets up expected params for ShopRepository.GetUserInventory
func (mmGetUserInventory *mShopRepositoryMockGetUserInventory) Expect(ctx context.Context, userID int64) *mShopRepositoryMockGetUserInventory {
	if mmGetUserInventory.mock.funcGetUserInventory != nil {
		mmGetUserInventory.mock.t.Fatalf("ShopRepositoryMock.GetUserInventory mock is already set by Set")
	}

	if mmGetUserInventory.defaultExpectation == nil {
		mmGetUserInventory.defaultExpectation = &ShopRepositoryMockGetUserInventoryExpectation{}
	}

	if mmGetUserInventory.defaultExpectation.paramPtrs != nil {
		mmGetUserInventory.mock.t.Fatalf("ShopRepositoryMock.GetUserInventory mock is already set by ExpectParams functions")
	}

	mmGetUserInventory.defaultExpectation.params = &ShopRepositoryMockGetUserInventoryParams{ctx, userID}
	mmGetUserInventory.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserInventory.expectations {
		if minimock.Equal(e.params, mmGetUserInventory.defaultExpectation.params) {
			mmGetUserInventory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserInventory.defaultExpectation.params)
		}
	}

	return mmGetUserInventory
}

// ExpectCtxParam1 sets up expected param ctx for ShopRepository.GetUserInventory
func (mmGetUserInventory *mShopRepositoryMockGetUserInventory) ExpectCtxParam1(ctx context.Context) *mShopRepositoryMockGetUserInventory {
	if mmGetUserInventory.mock.funcGetUserInventory != nil {
		mmGetUserInventory.mock.t.Fatalf("ShopRepositoryMock.GetUserInventory mock is already set by Set")
	}

	if mmGetUserInventory.defaultExpectation == nil {
		mmGetUserInventory.defaultExpectation = &ShopRepositoryMockGetUserInventoryExpectation{}
	}

	if mmGetUserInventory.defaultExpectation.params != nil {
		mmGetUserInventory.mock.t.Fatalf("ShopRepositoryMock.GetUserInventory mock is already set by Expect")
	}

	if mmGetUserInventory.defaultExpectation.paramPtrs == nil {
		mmGetUserInventory.defaultExpectation.paramPtrs = &ShopRepositoryMockGetUserInventoryParamPtrs{}
	}
	mmGetUserInventory.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserInventory.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserInventory
}

// ExpectUserIDParam2 sets up expected param userID for ShopRepository.GetUserInventory
func (mmGetUserInventory *mShopRepositoryMockGetUserInventory) ExpectUserIDParam2(userID int64) *mShopRepositoryMockGetUserInventory {
	if mmGetUserInventory.mock.funcGetUserInventory != nil {
		mmGetUserInventory.mock.t.Fatalf("ShopRepositoryMock.GetUserInventory mock is already set by Set")
	}

	if mmGetUserInventory.defaultExpectation == nil {
		mmGetUserInventory.defaultExpectation = &ShopRepositoryMockGetUserInventoryExpectation{}
	}

	if mmGetUserInventory.defaultExpectation.params != nil {
		mmGetUserInventory.mock.t.Fatalf("ShopRepositoryMock.GetUserInventory mock is already set by Expect")
	}

	if mmGetUserInventory.defaultExpectation.paramPtrs == nil {
		mmGetUserInventory.defaultExpectation.paramPtrs = &ShopRepositoryMockGetUserInventoryParamPtrs{}
	}
	mmGetUserInventory.defaultExpectation.paramPtrs.userID = &userID
	mmGetUserInventory.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetUserInventory
}

// Inspect accepts an inspector function that has same arguments as the ShopRepository.GetUserInventory
func (mmGetUserInventory *mShopRepositoryMockGetUserInventory) Inspect(f func(ctx context.Context, userID int64)) *mShopRepositoryMockGetUserInventory {
	if mmGetUserInventory.mock.inspectFuncGetUserInventory != nil {
		mmGetUserInventory.mock.t.Fatalf("Inspect function is already set for ShopRepositoryMock.GetUserInventory")
	}

	mmGetUserInventory.mock.inspectFuncGetUserInventory = f

	return mmGetUserInventory
}

// Return sets up results that will be returned by ShopRepository.GetUserInventory
func (mmGetUserInventory *mShopRepositoryMockGetUserInventory) Return(ia1 []model.InventoryItem, err error) *ShopRepositoryMock {
	if mmGetUserInventory.mock.funcGetUserInventory != nil {
		mmGetUserInventory.mock.t.Fatalf("ShopRepositoryMock.GetUserInventory mock is already set by Set")
	}

	if mmGetUserInventory.defaultExpectation == nil {
		mmGetUserInventory.defaultExpectation = &ShopRepositoryMockGetUserInventoryExpectation{mock: mmGetUserInventory.mock}
	}
	mmGetUserInventory.defaultExpectation.results = &ShopRepositoryMockGetUserInventoryResults{ia1, err}
	mmGetUserInventory.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserInventory.mock
}

// Set uses given function f to mock the ShopRepository.GetUserInventory method
func (mmGetUserInventory *mShopRepositoryMockGetUserInventory) Set(f func(ctx context.Context, userID int64) (ia1 []model.InventoryItem, err error)) *ShopRepositoryMock {
	if mmGetUserInventory.defaultExpectation != nil {
		mmGetUserInventory.mock.t.Fatalf("Default expectation is already set for the ShopRepository.GetUserInventory method")
	}

	if len(mmGetUserInventory.expectations) > 0 {
		mmGetUserInventory.mock.t.Fatalf("Some expectations are already set for the ShopRepository.GetUserInventory method")
	}

	mmGetUserInventory.mock.funcGetUserInventory = f
	mmGetUserInventory.mock.funcGetUserInventoryOrigin = minimock.CallerInfo(1)
	return mmGetUserInventory.mock
}

// When sets expectation for the ShopRepository.GetUserInventory which will trigger the result defined by the following
// Then helper
func (mmGetUserInventory *mShopRepositoryMockGetUserInventory) When(ctx context.Context, userID int64) *ShopRepositoryMockGetUserInventoryExpectation {
	if mmGetUserInventory.mock.funcGetUserInventory != nil {
		mmGetUserInventory.mock.t.Fatalf("ShopRepositoryMock.GetUserInventory mock is already set by Set")
	}

	expectation := &ShopRepositoryMockGetUserInventoryExpectation{
		mock:               mmGetUserInventory.mock,
		params:             &ShopRepositoryMockGetUserInventoryParams{ctx, userID},
		expectationOrigins: ShopRepositoryMockGetUserInventoryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserInventory.expectations = append(mmGetUserInventory.expectations, expectation)
	return expectation
}

// Then sets up ShopRepository.GetUserInventory return parameters for the expectation previously defined by the When method
func (e *ShopRepositoryMockGetUserInventoryExpectation) Then(ia1 []model.InventoryItem, err error) *ShopRepositoryMock {
	e.results = &ShopRepositoryMockGetUserInventoryResults{ia1, err}
	return e.mock
}

// Times sets number of times ShopRepository.GetUserInventory should be invoked
func (mmGetUserInventory *mShopRepositoryMockGetUserInventory) Times(n uint64) *mShopRepositoryMockGetUserInventory {
	if n == 0 {
		mmGetUserInventory.mock.t.Fatalf("Times of ShopRepositoryMock.GetUserInventory mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserInventory.expectedInvocations, n)
	mmGetUserInventory.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserInventory
}

func (mmGetUserInventory *mShopRepositoryMockGetUserInventory) invocationsDone() bool {
	if len(mmGetUserInventory.expectations) == 0 && mmGetUserInventory.defaultExpectation == nil && mmGetUserInventory.mock.funcGetUserInventory == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserInventory.mock.afterGetUserInventoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserInventory.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserInventory implements mm_repository.ShopRepository
func (mmGetUserInventory *ShopRepositoryMock) GetUserInventory(ctx context.Context, userID int64) (ia1 []model.InventoryItem, err error) {
	mm_atomic.AddUint64(&mmGetUserInventory.beforeGetUserInventoryCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserInventory.afterGetUserInventoryCounter, 1)

	mmGetUserInventory.t.Helper()

	if mmGetUserInventory.inspectFuncGetUserInventory != nil {
		mmGetUserInventory.inspectFuncGetUserInventory(ctx, userID)
	}

	mm_params := ShopRepositoryMockGetUserInventoryParams{ctx, userID}

	// Record call args
	mmGetUserInventory.GetUserInventoryMock.mutex.Lock()
	mmGetUserInventory.GetUserInventoryMock.callArgs = append(mmGetUserInventory.GetUserInventoryMock.callArgs, &mm_params)
	mmGetUserInventory.GetUserInventoryMock.mutex.Unlock()

	for _, e := range mmGetUserInventory.GetUserInventoryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmGetUserInventory.GetUserInventoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserInventory.GetUserInventoryMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserInventory.GetUserInventoryMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserInventory.GetUserInventoryMock.defaultExpectation.paramPtrs

		mm_got := ShopRepositoryMockGetUserInventoryParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserInventory.t.Errorf("ShopRepositoryMock.GetUserInventory got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserInventory.GetUserInventoryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetUserInventory.t.Errorf("ShopRepositoryMock.GetUserInventory got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserInventory.GetUserInventoryMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserInventory.t.Errorf("ShopRepositoryMock.GetUserInventory got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserInventory.GetUserInventoryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserInventory.GetUserInventoryMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserInventory.t.Fatal("No results are set for the ShopRepositoryMock.GetUserInventory")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmGetUserInventory.funcGetUserInventory != nil {
		return mmGetUserInventory.funcGetUserInventory(ctx, userID)
	}
	mmGetUserInventory.t.Fatalf("Unexpected call to ShopRepositoryMock.GetUserInventory. %v %v", ctx, userID)
	return
}

// GetUserInventoryAfterCounter returns a count of finished ShopRepositoryMock.GetUserInventory invocations
func (mmGetUserInventory *ShopRepositoryMock) GetUserInventoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserInventory.afterGetUserInventoryCounter)
}

// GetUserInventoryBeforeCounter returns a count of ShopRepositoryMock.GetUserInventory invocations
func (mmGetUserInventory *ShopRepositoryMock) GetUserInventoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserInventory.beforeGetUserInventoryCounter)
}

// Calls returns a list of arguments used in each call to ShopRepositoryMock.GetUserInventory.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserInventory *mShopRepositoryMockGetUserInventory) Calls() []*ShopRepositoryMockGetUserInventoryParams {
	mmGetUserInventory.mutex.RLock()

	argCopy := make([]*ShopRepositoryMockGetUserInventoryParams, len(mmGetUserInventory.callArgs))
	copy(argCopy, mmGetUserInventory.callArgs)

	mmGetUserInventory.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserInventoryDone returns true if the count of the GetUserInventory invocations corresponds
// the number of defined expectations
func (m *ShopRepositoryMock) MinimockGetUserInventoryDone() bool {
	if m.GetUserInventoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserInventoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserInventoryMock.invocationsDone()
}

// MinimockGetUserInventoryInspect logs each unmet expectation
func (m *ShopRepositoryMock) MinimockGetUserInventoryInspect() {
	for _, e := range m.GetUserInventoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ShopRepositoryMock.GetUserInventory at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserInventoryCounter := mm_atomic.LoadUint64(&m.afterGetUserInventoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserInventoryMock.defaultExpectation != nil && afterGetUserInventoryCounter < 1 {
		if m.GetUserInventoryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ShopRepositoryMock.GetUserInventory at\n%s", m.GetUserInventoryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ShopRepositoryMock.GetUserInventory at\n%s with params: %#v", m.GetUserInventoryMock.defaultExpectation.expectationOrigins.origin, *m.GetUserInventoryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserInventory != nil && afterGetUserInventoryCounter < 1 {
		m.t.Errorf("Expected call to ShopRepositoryMock.GetUserInventory at\n%s", m.funcGetUserInventoryOrigin)
	}

	if !m.GetUserInventoryMock.invocationsDone() && afterGetUserInventoryCounter > 0 {
		m.t.Errorf("Expected %d calls to ShopRepositoryMock.GetUserInventory at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserInventoryMock.expectedInvocations), m.GetUserInventoryMock.expectedInvocationsOrigin, afterGetUserInventoryCounter)
	}
}

type mShopRepositoryMockGetUserTransactions struct {
	optional           bool
	mock               *ShopRepositoryMock
	defaultExpectation *ShopRepositoryMockGetUserTransactionsExpectation
	expectations       []*ShopRepositoryMockGetUserTransactionsExpectation

	callArgs []*ShopRepositoryMockGetUserTransactionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ShopRepositoryMockGetUserTransactionsExpectation specifies expectation struct of the ShopRepository.GetUserTransactions
type ShopRepositoryMockGetUserTransactionsExpectation struct {
	mock               *ShopRepositoryMock
	params             *ShopRepositoryMockGetUserTransactionsParams
	paramPtrs          *ShopRepositoryMockGetUserTransactionsParamPtrs
	expectationOrigins ShopRepositoryMockGetUserTransactionsExpectationOrigins
	results            *ShopRepositoryMockGetUserTransactionsResults
	returnOrigin       string
	Counter            uint64
}

// ShopRepositoryMockGetUserTransactionsParams contains parameters of the ShopRepository.GetUserTransactions
type ShopRepositoryMockGetUserTransactionsParams struct {
	ctx    context.Context
	userID int64
}

// ShopRepositoryMockGetUserTransactionsParamPtrs contains pointers to parameters of the ShopRepository.GetUserTransactions
type ShopRepositoryMockGetUserTransactionsParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// ShopRepositoryMockGetUserTransactionsResults contains results of the ShopRepository.GetUserTransactions
type ShopRepositoryMockGetUserTransactionsResults struct {
	ra1 []model.Received
	sa1 []model.Sent
	err error
}

// ShopRepositoryMockGetUserTransactionsOrigins contains origins of expectations of the ShopRepository.GetUserTransactions
type ShopRepositoryMockGetUserTransactionsExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserTransactions *mShopRepositoryMockGetUserTransactions) Optional() *mShopRepositoryMockGetUserTransactions {
	mmGetUserTransactions.optional = true
	return mmGetUserTransactions
}

// Expect sets up expected params for ShopRepository.GetUserTransactions
func (mmGetUserTransactions *mShopRepositoryMockGetUserTransactions) Expect(ctx context.Context, userID int64) *mShopRepositoryMockGetUserTransactions {
	if mmGetUserTransactions.mock.funcGetUserTransactions != nil {
		mmGetUserTransactions.mock.t.Fatalf("ShopRepositoryMock.GetUserTransactions mock is already set by Set")
	}

	if mmGetUserTransactions.defaultExpectation == nil {
		mmGetUserTransactions.defaultExpectation = &ShopRepositoryMockGetUserTransactionsExpectation{}
	}

	if mmGetUserTransactions.defaultExpectation.paramPtrs != nil {
		mmGetUserTransactions.mock.t.Fatalf("ShopRepositoryMock.GetUserTransactions mock is already set by ExpectParams functions")
	}

	mmGetUserTransactions.defaultExpectation.params = &ShopRepositoryMockGetUserTransactionsParams{ctx, userID}
	mmGetUserTransactions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserTransactions.expectations {
		if minimock.Equal(e.params, mmGetUserTransactions.defaultExpectation.params) {
			mmGetUserTransactions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserTransactions.defaultExpectation.params)
		}
	}

	return mmGetUserTransactions
}

// ExpectCtxParam1 sets up expected param ctx for ShopRepository.GetUserTransactions
func (mmGetUserTransactions *mShopRepositoryMockGetUserTransactions) ExpectCtxParam1(ctx context.Context) *mShopRepositoryMockGetUserTransactions {
	if mmGetUserTransactions.mock.funcGetUserTransactions != nil {
		mmGetUserTransactions.mock.t.Fatalf("ShopRepositoryMock.GetUserTransactions mock is already set by Set")
	}

	if mmGetUserTransactions.defaultExpectation == nil {
		mmGetUserTransactions.defaultExpectation = &ShopRepositoryMockGetUserTransactionsExpectation{}
	}

	if mmGetUserTransactions.defaultExpectation.params != nil {
		mmGetUserTransactions.mock.t.Fatalf("ShopRepositoryMock.GetUserTransactions mock is already set by Expect")
	}

	if mmGetUserTransactions.defaultExpectation.paramPtrs == nil {
		mmGetUserTransactions.defaultExpectation.paramPtrs = &ShopRepositoryMockGetUserTransactionsParamPtrs{}
	}
	mmGetUserTransactions.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserTransactions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserTransactions
}

// ExpectUserIDParam2 sets up expected param userID for ShopRepository.GetUserTransactions
func (mmGetUserTransactions *mShopRepositoryMockGetUserTransactions) ExpectUserIDParam2(userID int64) *mShopRepositoryMockGetUserTransactions {
	if mmGetUserTransactions.mock.funcGetUserTransactions != nil {
		mmGetUserTransactions.mock.t.Fatalf("ShopRepositoryMock.GetUserTransactions mock is already set by Set")
	}

	if mmGetUserTransactions.defaultExpectation == nil {
		mmGetUserTransactions.defaultExpectation = &ShopRepositoryMockGetUserTransactionsExpectation{}
	}

	if mmGetUserTransactions.defaultExpectation.params != nil {
		mmGetUserTransactions.mock.t.Fatalf("ShopRepositoryMock.GetUserTransactions mock is already set by Expect")
	}

	if mmGetUserTransactions.defaultExpectation.paramPtrs == nil {
		mmGetUserTransactions.defaultExpectation.paramPtrs = &ShopRepositoryMockGetUserTransactionsParamPtrs{}
	}
	mmGetUserTransactions.defaultExpectation.paramPtrs.userID = &userID
	mmGetUserTransactions.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetUserTransactions
}

// Inspect accepts an inspector function that has same arguments as the ShopRepository.GetUserTransactions
func (mmGetUserTransactions *mShopRepositoryMockGetUserTransactions) Inspect(f func(ctx context.Context, userID int64)) *mShopRepositoryMockGetUserTransactions {
	if mmGetUserTransactions.mock.inspectFuncGetUserTransactions != nil {
		mmGetUserTransactions.mock.t.Fatalf("Inspect function is already set for ShopRepositoryMock.GetUserTransactions")
	}

	mmGetUserTransactions.mock.inspectFuncGetUserTransactions = f

	return mmGetUserTransactions
}

// Return sets up results that will be returned by ShopRepository.GetUserTransactions
func (mmGetUserTransactions *mShopRepositoryMockGetUserTransactions) Return(ra1 []model.Received, sa1 []model.Sent, err error) *ShopRepositoryMock {
	if mmGetUserTransactions.mock.funcGetUserTransactions != nil {
		mmGetUserTransactions.mock.t.Fatalf("ShopRepositoryMock.GetUserTransactions mock is already set by Set")
	}

	if mmGetUserTransactions.defaultExpectation == nil {
		mmGetUserTransactions.defaultExpectation = &ShopRepositoryMockGetUserTransactionsExpectation{mock: mmGetUserTransactions.mock}
	}
	mmGetUserTransactions.defaultExpectation.results = &ShopRepositoryMockGetUserTransactionsResults{ra1, sa1, err}
	mmGetUserTransactions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserTransactions.mock
}

// Set uses given function f to mock the ShopRepository.GetUserTransactions method
func (mmGetUserTransactions *mShopRepositoryMockGetUserTransactions) Set(f func(ctx context.Context, userID int64) (ra1 []model.Received, sa1 []model.Sent, err error)) *ShopRepositoryMock {
	if mmGetUserTransactions.defaultExpectation != nil {
		mmGetUserTransactions.mock.t.Fatalf("Default expectation is already set for the ShopRepository.GetUserTransactions method")
	}

	if len(mmGetUserTransactions.expectations) > 0 {
		mmGetUserTransactions.mock.t.Fatalf("Some expectations are already set for the ShopRepository.GetUserTransactions method")
	}

	mmGetUserTransactions.mock.funcGetUserTransactions = f
	mmGetUserTransactions.mock.funcGetUserTransactionsOrigin = minimock.CallerInfo(1)
	return mmGetUserTransactions.mock
}

// When sets expectation for the ShopRepository.GetUserTransactions which will trigger the result defined by the following
// Then helper
func (mmGetUserTransactions *mShopRepositoryMockGetUserTransactions) When(ctx context.Context, userID int64) *ShopRepositoryMockGetUserTransactionsExpectation {
	if mmGetUserTransactions.mock.funcGetUserTransactions != nil {
		mmGetUserTransactions.mock.t.Fatalf("ShopRepositoryMock.GetUserTransactions mock is already set by Set")
	}

	expectation := &ShopRepositoryMockGetUserTransactionsExpectation{
		mock:               mmGetUserTransactions.mock,
		params:             &ShopRepositoryMockGetUserTransactionsParams{ctx, userID},
		expectationOrigins: ShopRepositoryMockGetUserTransactionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserTransactions.expectations = append(mmGetUserTransactions.expectations, expectation)
	return expectation
}

// Then sets up ShopRepository.GetUserTransactions return parameters for the expectation previously defined by the When method
func (e *ShopRepositoryMockGetUserTransactionsExpectation) Then(ra1 []model.Received, sa1 []model.Sent, err error) *ShopRepositoryMock {
	e.results = &ShopRepositoryMockGetUserTransactionsResults{ra1, sa1, err}
	return e.mock
}

// Times sets number of times ShopRepository.GetUserTransactions should be invoked
func (mmGetUserTransactions *mShopRepositoryMockGetUserTransactions) Times(n uint64) *mShopRepositoryMockGetUserTransactions {
	if n == 0 {
		mmGetUserTransactions.mock.t.Fatalf("Times of ShopRepositoryMock.GetUserTransactions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserTransactions.expectedInvocations, n)
	mmGetUserTransactions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserTransactions
}

func (mmGetUserTransactions *mShopRepositoryMockGetUserTransactions) invocationsDone() bool {
	if len(mmGetUserTransactions.expectations) == 0 && mmGetUserTransactions.defaultExpectation == nil && mmGetUserTransactions.mock.funcGetUserTransactions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserTransactions.mock.afterGetUserTransactionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserTransactions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserTransactions implements mm_repository.ShopRepository
func (mmGetUserTransactions *ShopRepositoryMock) GetUserTransactions(ctx context.Context, userID int64) (ra1 []model.Received, sa1 []model.Sent, err error) {
	mm_atomic.AddUint64(&mmGetUserTransactions.beforeGetUserTransactionsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserTransactions.afterGetUserTransactionsCounter, 1)

	mmGetUserTransactions.t.Helper()

	if mmGetUserTransactions.inspectFuncGetUserTransactions != nil {
		mmGetUserTransactions.inspectFuncGetUserTransactions(ctx, userID)
	}

	mm_params := ShopRepositoryMockGetUserTransactionsParams{ctx, userID}

	// Record call args
	mmGetUserTransactions.GetUserTransactionsMock.mutex.Lock()
	mmGetUserTransactions.GetUserTransactionsMock.callArgs = append(mmGetUserTransactions.GetUserTransactionsMock.callArgs, &mm_params)
	mmGetUserTransactions.GetUserTransactionsMock.mutex.Unlock()

	for _, e := range mmGetUserTransactions.GetUserTransactionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ra1, e.results.sa1, e.results.err
		}
	}

	if mmGetUserTransactions.GetUserTransactionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserTransactions.GetUserTransactionsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserTransactions.GetUserTransactionsMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserTransactions.GetUserTransactionsMock.defaultExpectation.paramPtrs

		mm_got := ShopRepositoryMockGetUserTransactionsParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserTransactions.t.Errorf("ShopRepositoryMock.GetUserTransactions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserTransactions.GetUserTransactionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetUserTransactions.t.Errorf("ShopRepositoryMock.GetUserTransactions got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserTransactions.GetUserTransactionsMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserTransactions.t.Errorf("ShopRepositoryMock.GetUserTransactions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserTransactions.GetUserTransactionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserTransactions.GetUserTransactionsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserTransactions.t.Fatal("No results are set for the ShopRepositoryMock.GetUserTransactions")
		}
		return (*mm_results).ra1, (*mm_results).sa1, (*mm_results).err
	}
	if mmGetUserTransactions.funcGetUserTransactions != nil {
		return mmGetUserTransactions.funcGetUserTransactions(ctx, userID)
	}
	mmGetUserTransactions.t.Fatalf("Unexpected call to ShopRepositoryMock.GetUserTransactions. %v %v", ctx, userID)
	return
}

// GetUserTransactionsAfterCounter returns a count of finished ShopRepositoryMock.GetUserTransactions invocations
func (mmGetUserTransactions *ShopRepositoryMock) GetUserTransactionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserTransactions.afterGetUserTransactionsCounter)
}

// GetUserTransactionsBeforeCounter returns a count of ShopRepositoryMock.GetUserTransactions invocations
func (mmGetUserTransactions *ShopRepositoryMock) GetUserTransactionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserTransactions.beforeGetUserTransactionsCounter)
}

// Calls returns a list of arguments used in each call to ShopRepositoryMock.GetUserTransactions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserTransactions *mShopRepositoryMockGetUserTransactions) Calls() []*ShopRepositoryMockGetUserTransactionsParams {
	mmGetUserTransactions.mutex.RLock()

	argCopy := make([]*ShopRepositoryMockGetUserTransactionsParams, len(mmGetUserTransactions.callArgs))
	copy(argCopy, mmGetUserTransactions.callArgs)

	mmGetUserTransactions.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserTransactionsDone returns true if the count of the GetUserTransactions invocations corresponds
// the number of defined expectations
func (m *ShopRepositoryMock) MinimockGetUserTransactionsDone() bool {
	if m.GetUserTransactionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserTransactionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserTransactionsMock.invocationsDone()
}

// MinimockGetUserTransactionsInspect logs each unmet expectation
func (m *ShopRepositoryMock) MinimockGetUserTransactionsInspect() {
	for _, e := range m.GetUserTransactionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ShopRepositoryMock.GetUserTransactions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserTransactionsCounter := mm_atomic.LoadUint64(&m.afterGetUserTransactionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserTransactionsMock.defaultExpectation != nil && afterGetUserTransactionsCounter < 1 {
		if m.GetUserTransactionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ShopRepositoryMock.GetUserTransactions at\n%s", m.GetUserTransactionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ShopRepositoryMock.GetUserTransactions at\n%s with params: %#v", m.GetUserTransactionsMock.defaultExpectation.expectationOrigins.origin, *m.GetUserTransactionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserTransactions != nil && afterGetUserTransactionsCounter < 1 {
		m.t.Errorf("Expected call to ShopRepositoryMock.GetUserTransactions at\n%s", m.funcGetUserTransactionsOrigin)
	}

	if !m.GetUserTransactionsMock.invocationsDone() && afterGetUserTransactionsCounter > 0 {
		m.t.Errorf("Expected %d calls to ShopRepositoryMock.GetUserTransactions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserTransactionsMock.expectedInvocations), m.GetUserTransactionsMock.expectedInvocationsOrigin, afterGetUserTransactionsCounter)
	}
}

type mShopRepositoryMockInsertNewInventory struct {
	optional           bool
	mock               *ShopRepositoryMock
	defaultExpectation *ShopRepositoryMockInsertNewInventoryExpectation
	expectations       []*ShopRepositoryMockInsertNewInventoryExpectation

	callArgs []*ShopRepositoryMockInsertNewInventoryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ShopRepositoryMockInsertNewInventoryExpectation specifies expectation struct of the ShopRepository.InsertNewInventory
type ShopRepositoryMockInsertNewInventoryExpectation struct {
	mock               *ShopRepositoryMock
	params             *ShopRepositoryMockInsertNewInventoryParams
	paramPtrs          *ShopRepositoryMockInsertNewInventoryParamPtrs
	expectationOrigins ShopRepositoryMockInsertNewInventoryExpectationOrigins
	results            *ShopRepositoryMockInsertNewInventoryResults
	returnOrigin       string
	Counter            uint64
}

// ShopRepositoryMockInsertNewInventoryParams contains parameters of the ShopRepository.InsertNewInventory
type ShopRepositoryMockInsertNewInventoryParams struct {
	ctx    context.Context
	userID int64
	item   string
}

// ShopRepositoryMockInsertNewInventoryParamPtrs contains pointers to parameters of the ShopRepository.InsertNewInventory
type ShopRepositoryMockInsertNewInventoryParamPtrs struct {
	ctx    *context.Context
	userID *int64
	item   *string
}

// ShopRepositoryMockInsertNewInventoryResults contains results of the ShopRepository.InsertNewInventory
type ShopRepositoryMockInsertNewInventoryResults struct {
	err error
}

// ShopRepositoryMockInsertNewInventoryOrigins contains origins of expectations of the ShopRepository.InsertNewInventory
type ShopRepositoryMockInsertNewInventoryExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originItem   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInsertNewInventory *mShopRepositoryMockInsertNewInventory) Optional() *mShopRepositoryMockInsertNewInventory {
	mmInsertNewInventory.optional = true
	return mmInsertNewInventory
}

// Expect sets up expected params for ShopRepository.InsertNewInventory
func (mmInsertNewInventory *mShopRepositoryMockInsertNewInventory) Expect(ctx context.Context, userID int64, item string) *mShopRepositoryMockInsertNewInventory {
	if mmInsertNewInventory.mock.funcInsertNewInventory != nil {
		mmInsertNewInventory.mock.t.Fatalf("ShopRepositoryMock.InsertNewInventory mock is already set by Set")
	}

	if mmInsertNewInventory.defaultExpectation == nil {
		mmInsertNewInventory.defaultExpectation = &ShopRepositoryMockInsertNewInventoryExpectation{}
	}

	if mmInsertNewInventory.defaultExpectation.paramPtrs != nil {
		mmInsertNewInventory.mock.t.Fatalf("ShopRepositoryMock.InsertNewInventory mock is already set by ExpectParams functions")
	}

	mmInsertNewInventory.defaultExpectation.params = &ShopRepositoryMockInsertNewInventoryParams{ctx, userID, item}
	mmInsertNewInventory.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInsertNewInventory.expectations {
		if minimock.Equal(e.params, mmInsertNewInventory.defaultExpectation.params) {
			mmInsertNewInventory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertNewInventory.defaultExpectation.params)
		}
	}

	return mmInsertNewInventory
}

// ExpectCtxParam1 sets up expected param ctx for ShopRepository.InsertNewInventory
func (mmInsertNewInventory *mShopRepositoryMockInsertNewInventory) ExpectCtxParam1(ctx context.Context) *mShopRepositoryMockInsertNewInventory {
	if mmInsertNewInventory.mock.funcInsertNewInventory != nil {
		mmInsertNewInventory.mock.t.Fatalf("ShopRepositoryMock.InsertNewInventory mock is already set by Set")
	}

	if mmInsertNewInventory.defaultExpectation == nil {
		mmInsertNewInventory.defaultExpectation = &ShopRepositoryMockInsertNewInventoryExpectation{}
	}

	if mmInsertNewInventory.defaultExpectation.params != nil {
		mmInsertNewInventory.mock.t.Fatalf("ShopRepositoryMock.InsertNewInventory mock is already set by Expect")
	}

	if mmInsertNewInventory.defaultExpectation.paramPtrs == nil {
		mmInsertNewInventory.defaultExpectation.paramPtrs = &ShopRepositoryMockInsertNewInventoryParamPtrs{}
	}
	mmInsertNewInventory.defaultExpectation.paramPtrs.ctx = &ctx
	mmInsertNewInventory.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmInsertNewInventory
}

// ExpectUserIDParam2 sets up expected param userID for ShopRepository.InsertNewInventory
func (mmInsertNewInventory *mShopRepositoryMockInsertNewInventory) ExpectUserIDParam2(userID int64) *mShopRepositoryMockInsertNewInventory {
	if mmInsertNewInventory.mock.funcInsertNewInventory != nil {
		mmInsertNewInventory.mock.t.Fatalf("ShopRepositoryMock.InsertNewInventory mock is already set by Set")
	}

	if mmInsertNewInventory.defaultExpectation == nil {
		mmInsertNewInventory.defaultExpectation = &ShopRepositoryMockInsertNewInventoryExpectation{}
	}

	if mmInsertNewInventory.defaultExpectation.params != nil {
		mmInsertNewInventory.mock.t.Fatalf("ShopRepositoryMock.InsertNewInventory mock is already set by Expect")
	}

	if mmInsertNewInventory.defaultExpectation.paramPtrs == nil {
		mmInsertNewInventory.defaultExpectation.paramPtrs = &ShopRepositoryMockInsertNewInventoryParamPtrs{}
	}
	mmInsertNewInventory.defaultExpectation.paramPtrs.userID = &userID
	mmInsertNewInventory.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmInsertNewInventory
}

// ExpectItemParam3 sets up expected param item for ShopRepository.InsertNewInventory
func (mmInsertNewInventory *mShopRepositoryMockInsertNewInventory) ExpectItemParam3(item string) *mShopRepositoryMockInsertNewInventory {
	if mmInsertNewInventory.mock.funcInsertNewInventory != nil {
		mmInsertNewInventory.mock.t.Fatalf("ShopRepositoryMock.InsertNewInventory mock is already set by Set")
	}

	if mmInsertNewInventory.defaultExpectation == nil {
		mmInsertNewInventory.defaultExpectation = &ShopRepositoryMockInsertNewInventoryExpectation{}
	}

	if mmInsertNewInventory.defaultExpectation.params != nil {
		mmInsertNewInventory.mock.t.Fatalf("ShopRepositoryMock.InsertNewInventory mock is already set by Expect")
	}

	if mmInsertNewInventory.defaultExpectation.paramPtrs == nil {
		mmInsertNewInventory.defaultExpectation.paramPtrs = &ShopRepositoryMockInsertNewInventoryParamPtrs{}
	}
	mmInsertNewInventory.defaultExpectation.paramPtrs.item = &item
	mmInsertNewInventory.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmInsertNewInventory
}

// Inspect accepts an inspector function that has same arguments as the ShopRepository.InsertNewInventory
func (mmInsertNewInventory *mShopRepositoryMockInsertNewInventory) Inspect(f func(ctx context.Context, userID int64, item string)) *mShopRepositoryMockInsertNewInventory {
	if mmInsertNewInventory.mock.inspectFuncInsertNewInventory != nil {
		mmInsertNewInventory.mock.t.Fatalf("Inspect function is already set for ShopRepositoryMock.InsertNewInventory")
	}

	mmInsertNewInventory.mock.inspectFuncInsertNewInventory = f

	return mmInsertNewInventory
}

// Return sets up results that will be returned by ShopRepository.InsertNewInventory
func (mmInsertNewInventory *mShopRepositoryMockInsertNewInventory) Return(err error) *ShopRepositoryMock {
	if mmInsertNewInventory.mock.funcInsertNewInventory != nil {
		mmInsertNewInventory.mock.t.Fatalf("ShopRepositoryMock.InsertNewInventory mock is already set by Set")
	}

	if mmInsertNewInventory.defaultExpectation == nil {
		mmInsertNewInventory.defaultExpectation = &ShopRepositoryMockInsertNewInventoryExpectation{mock: mmInsertNewInventory.mock}
	}
	mmInsertNewInventory.defaultExpectation.results = &ShopRepositoryMockInsertNewInventoryResults{err}
	mmInsertNewInventory.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInsertNewInventory.mock
}

// Set uses given function f to mock the ShopRepository.InsertNewInventory method
func (mmInsertNewInventory *mShopRepositoryMockInsertNewInventory) Set(f func(ctx context.Context, userID int64, item string) (err error)) *ShopRepositoryMock {
	if mmInsertNewInventory.defaultExpectation != nil {
		mmInsertNewInventory.mock.t.Fatalf("Default expectation is already set for the ShopRepository.InsertNewInventory method")
	}

	if len(mmInsertNewInventory.expectations) > 0 {
		mmInsertNewInventory.mock.t.Fatalf("Some expectations are already set for the ShopRepository.InsertNewInventory method")
	}

	mmInsertNewInventory.mock.funcInsertNewInventory = f
	mmInsertNewInventory.mock.funcInsertNewInventoryOrigin = minimock.CallerInfo(1)
	return mmInsertNewInventory.mock
}

// When sets expectation for the ShopRepository.InsertNewInventory which will trigger the result defined by the following
// Then helper
func (mmInsertNewInventory *mShopRepositoryMockInsertNewInventory) When(ctx context.Context, userID int64, item string) *ShopRepositoryMockInsertNewInventoryExpectation {
	if mmInsertNewInventory.mock.funcInsertNewInventory != nil {
		mmInsertNewInventory.mock.t.Fatalf("ShopRepositoryMock.InsertNewInventory mock is already set by Set")
	}

	expectation := &ShopRepositoryMockInsertNewInventoryExpectation{
		mock:               mmInsertNewInventory.mock,
		params:             &ShopRepositoryMockInsertNewInventoryParams{ctx, userID, item},
		expectationOrigins: ShopRepositoryMockInsertNewInventoryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInsertNewInventory.expectations = append(mmInsertNewInventory.expectations, expectation)
	return expectation
}

// Then sets up ShopRepository.InsertNewInventory return parameters for the expectation previously defined by the When method
func (e *ShopRepositoryMockInsertNewInventoryExpectation) Then(err error) *ShopRepositoryMock {
	e.results = &ShopRepositoryMockInsertNewInventoryResults{err}
	return e.mock
}

// Times sets number of times ShopRepository.InsertNewInventory should be invoked
func (mmInsertNewInventory *mShopRepositoryMockInsertNewInventory) Times(n uint64) *mShopRepositoryMockInsertNewInventory {
	if n == 0 {
		mmInsertNewInventory.mock.t.Fatalf("Times of ShopRepositoryMock.InsertNewInventory mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInsertNewInventory.expectedInvocations, n)
	mmInsertNewInventory.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInsertNewInventory
}

func (mmInsertNewInventory *mShopRepositoryMockInsertNewInventory) invocationsDone() bool {
	if len(mmInsertNewInventory.expectations) == 0 && mmInsertNewInventory.defaultExpectation == nil && mmInsertNewInventory.mock.funcInsertNewInventory == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInsertNewInventory.mock.afterInsertNewInventoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInsertNewInventory.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// InsertNewInventory implements mm_repository.ShopRepository
func (mmInsertNewInventory *ShopRepositoryMock) InsertNewInventory(ctx context.Context, userID int64, item string) (err error) {
	mm_atomic.AddUint64(&mmInsertNewInventory.beforeInsertNewInventoryCounter, 1)
	defer mm_atomic.AddUint64(&mmInsertNewInventory.afterInsertNewInventoryCounter, 1)

	mmInsertNewInventory.t.Helper()

	if mmInsertNewInventory.inspectFuncInsertNewInventory != nil {
		mmInsertNewInventory.inspectFuncInsertNewInventory(ctx, userID, item)
	}

	mm_params := ShopRepositoryMockInsertNewInventoryParams{ctx, userID, item}

	// Record call args
	mmInsertNewInventory.InsertNewInventoryMock.mutex.Lock()
	mmInsertNewInventory.InsertNewInventoryMock.callArgs = append(mmInsertNewInventory.InsertNewInventoryMock.callArgs, &mm_params)
	mmInsertNewInventory.InsertNewInventoryMock.mutex.Unlock()

	for _, e := range mmInsertNewInventory.InsertNewInventoryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInsertNewInventory.InsertNewInventoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertNewInventory.InsertNewInventoryMock.defaultExpectation.Counter, 1)
		mm_want := mmInsertNewInventory.InsertNewInventoryMock.defaultExpectation.params
		mm_want_ptrs := mmInsertNewInventory.InsertNewInventoryMock.defaultExpectation.paramPtrs

		mm_got := ShopRepositoryMockInsertNewInventoryParams{ctx, userID, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInsertNewInventory.t.Errorf("ShopRepositoryMock.InsertNewInventory got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertNewInventory.InsertNewInventoryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmInsertNewInventory.t.Errorf("ShopRepositoryMock.InsertNewInventory got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertNewInventory.InsertNewInventoryMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmInsertNewInventory.t.Errorf("ShopRepositoryMock.InsertNewInventory got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertNewInventory.InsertNewInventoryMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertNewInventory.t.Errorf("ShopRepositoryMock.InsertNewInventory got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInsertNewInventory.InsertNewInventoryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertNewInventory.InsertNewInventoryMock.defaultExpectation.results
		if mm_results == nil {
			mmInsertNewInventory.t.Fatal("No results are set for the ShopRepositoryMock.InsertNewInventory")
		}
		return (*mm_results).err
	}
	if mmInsertNewInventory.funcInsertNewInventory != nil {
		return mmInsertNewInventory.funcInsertNewInventory(ctx, userID, item)
	}
	mmInsertNewInventory.t.Fatalf("Unexpected call to ShopRepositoryMock.InsertNewInventory. %v %v %v", ctx, userID, item)
	return
}

// InsertNewInventoryAfterCounter returns a count of finished ShopRepositoryMock.InsertNewInventory invocations
func (mmInsertNewInventory *ShopRepositoryMock) InsertNewInventoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertNewInventory.afterInsertNewInventoryCounter)
}

// InsertNewInventoryBeforeCounter returns a count of ShopRepositoryMock.InsertNewInventory invocations
func (mmInsertNewInventory *ShopRepositoryMock) InsertNewInventoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertNewInventory.beforeInsertNewInventoryCounter)
}

// Calls returns a list of arguments used in each call to ShopRepositoryMock.InsertNewInventory.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertNewInventory *mShopRepositoryMockInsertNewInventory) Calls() []*ShopRepositoryMockInsertNewInventoryParams {
	mmInsertNewInventory.mutex.RLock()

	argCopy := make([]*ShopRepositoryMockInsertNewInventoryParams, len(mmInsertNewInventory.callArgs))
	copy(argCopy, mmInsertNewInventory.callArgs)

	mmInsertNewInventory.mutex.RUnlock()

	return argCopy
}

// MinimockInsertNewInventoryDone returns true if the count of the InsertNewInventory invocations corresponds
// the number of defined expectations
func (m *ShopRepositoryMock) MinimockInsertNewInventoryDone() bool {
	if m.InsertNewInventoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InsertNewInventoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InsertNewInventoryMock.invocationsDone()
}

// MinimockInsertNewInventoryInspect logs each unmet expectation
func (m *ShopRepositoryMock) MinimockInsertNewInventoryInspect() {
	for _, e := range m.InsertNewInventoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ShopRepositoryMock.InsertNewInventory at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInsertNewInventoryCounter := mm_atomic.LoadUint64(&m.afterInsertNewInventoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InsertNewInventoryMock.defaultExpectation != nil && afterInsertNewInventoryCounter < 1 {
		if m.InsertNewInventoryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ShopRepositoryMock.InsertNewInventory at\n%s", m.InsertNewInventoryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ShopRepositoryMock.InsertNewInventory at\n%s with params: %#v", m.InsertNewInventoryMock.defaultExpectation.expectationOrigins.origin, *m.InsertNewInventoryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertNewInventory != nil && afterInsertNewInventoryCounter < 1 {
		m.t.Errorf("Expected call to ShopRepositoryMock.InsertNewInventory at\n%s", m.funcInsertNewInventoryOrigin)
	}

	if !m.InsertNewInventoryMock.invocationsDone() && afterInsertNewInventoryCounter > 0 {
		m.t.Errorf("Expected %d calls to ShopRepositoryMock.InsertNewInventory at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InsertNewInventoryMock.expectedInvocations), m.InsertNewInventoryMock.expectedInvocationsOrigin, afterInsertNewInventoryCounter)
	}
}

type mShopRepositoryMockUpdateInventory struct {
	optional           bool
	mock               *ShopRepositoryMock
	defaultExpectation *ShopRepositoryMockUpdateInventoryExpectation
	expectations       []*ShopRepositoryMockUpdateInventoryExpectation

	callArgs []*ShopRepositoryMockUpdateInventoryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ShopRepositoryMockUpdateInventoryExpectation specifies expectation struct of the ShopRepository.UpdateInventory
type ShopRepositoryMockUpdateInventoryExpectation struct {
	mock               *ShopRepositoryMock
	params             *ShopRepositoryMockUpdateInventoryParams
	paramPtrs          *ShopRepositoryMockUpdateInventoryParamPtrs
	expectationOrigins ShopRepositoryMockUpdateInventoryExpectationOrigins
	results            *ShopRepositoryMockUpdateInventoryResults
	returnOrigin       string
	Counter            uint64
}

// ShopRepositoryMockUpdateInventoryParams contains parameters of the ShopRepository.UpdateInventory
type ShopRepositoryMockUpdateInventoryParams struct {
	ctx         context.Context
	item        string
	id          int64
	newQuantity int64
}

// ShopRepositoryMockUpdateInventoryParamPtrs contains pointers to parameters of the ShopRepository.UpdateInventory
type ShopRepositoryMockUpdateInventoryParamPtrs struct {
	ctx         *context.Context
	item        *string
	id          *int64
	newQuantity *int64
}

// ShopRepositoryMockUpdateInventoryResults contains results of the ShopRepository.UpdateInventory
type ShopRepositoryMockUpdateInventoryResults struct {
	err error
}

// ShopRepositoryMockUpdateInventoryOrigins contains origins of expectations of the ShopRepository.UpdateInventory
type ShopRepositoryMockUpdateInventoryExpectationOrigins struct {
	origin            string
	originCtx         string
	originItem        string
	originId          string
	originNewQuantity string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateInventory *mShopRepositoryMockUpdateInventory) Optional() *mShopRepositoryMockUpdateInventory {
	mmUpdateInventory.optional = true
	return mmUpdateInventory
}

// Expect sets up expected params for ShopRepository.UpdateInventory
func (mmUpdateInventory *mShopRepositoryMockUpdateInventory) Expect(ctx context.Context, item string, id int64, newQuantity int64) *mShopRepositoryMockUpdateInventory {
	if mmUpdateInventory.mock.funcUpdateInventory != nil {
		mmUpdateInventory.mock.t.Fatalf("ShopRepositoryMock.UpdateInventory mock is already set by Set")
	}

	if mmUpdateInventory.defaultExpectation == nil {
		mmUpdateInventory.defaultExpectation = &ShopRepositoryMockUpdateInventoryExpectation{}
	}

	if mmUpdateInventory.defaultExpectation.paramPtrs != nil {
		mmUpdateInventory.mock.t.Fatalf("ShopRepositoryMock.UpdateInventory mock is already set by ExpectParams functions")
	}

	mmUpdateInventory.defaultExpectation.params = &ShopRepositoryMockUpdateInventoryParams{ctx, item, id, newQuantity}
	mmUpdateInventory.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateInventory.expectations {
		if minimock.Equal(e.params, mmUpdateInventory.defaultExpectation.params) {
			mmUpdateInventory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateInventory.defaultExpectation.params)
		}
	}

	return mmUpdateInventory
}

// ExpectCtxParam1 sets up expected param ctx for ShopRepository.UpdateInventory
func (mmUpdateInventory *mShopRepositoryMockUpdateInventory) ExpectCtxParam1(ctx context.Context) *mShopRepositoryMockUpdateInventory {
	if mmUpdateInventory.mock.funcUpdateInventory != nil {
		mmUpdateInventory.mock.t.Fatalf("ShopRepositoryMock.UpdateInventory mock is already set by Set")
	}

	if mmUpdateInventory.defaultExpectation == nil {
		mmUpdateInventory.defaultExpectation = &ShopRepositoryMockUpdateInventoryExpectation{}
	}

	if mmUpdateInventory.defaultExpectation.params != nil {
		mmUpdateInventory.mock.t.Fatalf("ShopRepositoryMock.UpdateInventory mock is already set by Expect")
	}

	if mmUpdateInventory.defaultExpectation.paramPtrs == nil {
		mmUpdateInventory.defaultExpectation.paramPtrs = &ShopRepositoryMockUpdateInventoryParamPtrs{}
	}
	mmUpdateInventory.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateInventory.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateInventory
}

// ExpectItemParam2 sets up expected param item for ShopRepository.UpdateInventory
func (mmUpdateInventory *mShopRepositoryMockUpdateInventory) ExpectItemParam2(item string) *mShopRepositoryMockUpdateInventory {
	if mmUpdateInventory.mock.funcUpdateInventory != nil {
		mmUpdateInventory.mock.t.Fatalf("ShopRepositoryMock.UpdateInventory mock is already set by Set")
	}

	if mmUpdateInventory.defaultExpectation == nil {
		mmUpdateInventory.defaultExpectation = &ShopRepositoryMockUpdateInventoryExpectation{}
	}

	if mmUpdateInventory.defaultExpectation.params != nil {
		mmUpdateInventory.mock.t.Fatalf("ShopRepositoryMock.UpdateInventory mock is already set by Expect")
	}

	if mmUpdateInventory.defaultExpectation.paramPtrs == nil {
		mmUpdateInventory.defaultExpectation.paramPtrs = &ShopRepositoryMockUpdateInventoryParamPtrs{}
	}
	mmUpdateInventory.defaultExpectation.paramPtrs.item = &item
	mmUpdateInventory.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmUpdateInventory
}

// ExpectIdParam3 sets up expected param id for ShopRepository.UpdateInventory
func (mmUpdateInventory *mShopRepositoryMockUpdateInventory) ExpectIdParam3(id int64) *mShopRepositoryMockUpdateInventory {
	if mmUpdateInventory.mock.funcUpdateInventory != nil {
		mmUpdateInventory.mock.t.Fatalf("ShopRepositoryMock.UpdateInventory mock is already set by Set")
	}

	if mmUpdateInventory.defaultExpectation == nil {
		mmUpdateInventory.defaultExpectation = &ShopRepositoryMockUpdateInventoryExpectation{}
	}

	if mmUpdateInventory.defaultExpectation.params != nil {
		mmUpdateInventory.mock.t.Fatalf("ShopRepositoryMock.UpdateInventory mock is already set by Expect")
	}

	if mmUpdateInventory.defaultExpectation.paramPtrs == nil {
		mmUpdateInventory.defaultExpectation.paramPtrs = &ShopRepositoryMockUpdateInventoryParamPtrs{}
	}
	mmUpdateInventory.defaultExpectation.paramPtrs.id = &id
	mmUpdateInventory.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateInventory
}

// ExpectNewQuantityParam4 sets up expected param newQuantity for ShopRepository.UpdateInventory
func (mmUpdateInventory *mShopRepositoryMockUpdateInventory) ExpectNewQuantityParam4(newQuantity int64) *mShopRepositoryMockUpdateInventory {
	if mmUpdateInventory.mock.funcUpdateInventory != nil {
		mmUpdateInventory.mock.t.Fatalf("ShopRepositoryMock.UpdateInventory mock is already set by Set")
	}

	if mmUpdateInventory.defaultExpectation == nil {
		mmUpdateInventory.defaultExpectation = &ShopRepositoryMockUpdateInventoryExpectation{}
	}

	if mmUpdateInventory.defaultExpectation.params != nil {
		mmUpdateInventory.mock.t.Fatalf("ShopRepositoryMock.UpdateInventory mock is already set by Expect")
	}

	if mmUpdateInventory.defaultExpectation.paramPtrs == nil {
		mmUpdateInventory.defaultExpectation.paramPtrs = &ShopRepositoryMockUpdateInventoryParamPtrs{}
	}
	mmUpdateInventory.defaultExpectation.paramPtrs.newQuantity = &newQuantity
	mmUpdateInventory.defaultExpectation.expectationOrigins.originNewQuantity = minimock.CallerInfo(1)

	return mmUpdateInventory
}

// Inspect accepts an inspector function that has same arguments as the ShopRepository.UpdateInventory
func (mmUpdateInventory *mShopRepositoryMockUpdateInventory) Inspect(f func(ctx context.Context, item string, id int64, newQuantity int64)) *mShopRepositoryMockUpdateInventory {
	if mmUpdateInventory.mock.inspectFuncUpdateInventory != nil {
		mmUpdateInventory.mock.t.Fatalf("Inspect function is already set for ShopRepositoryMock.UpdateInventory")
	}

	mmUpdateInventory.mock.inspectFuncUpdateInventory = f

	return mmUpdateInventory
}

// Return sets up results that will be returned by ShopRepository.UpdateInventory
func (mmUpdateInventory *mShopRepositoryMockUpdateInventory) Return(err error) *ShopRepositoryMock {
	if mmUpdateInventory.mock.funcUpdateInventory != nil {
		mmUpdateInventory.mock.t.Fatalf("ShopRepositoryMock.UpdateInventory mock is already set by Set")
	}

	if mmUpdateInventory.defaultExpectation == nil {
		mmUpdateInventory.defaultExpectation = &ShopRepositoryMockUpdateInventoryExpectation{mock: mmUpdateInventory.mock}
	}
	mmUpdateInventory.defaultExpectation.results = &ShopRepositoryMockUpdateInventoryResults{err}
	mmUpdateInventory.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateInventory.mock
}

// Set uses given function f to mock the ShopRepository.UpdateInventory method
func (mmUpdateInventory *mShopRepositoryMockUpdateInventory) Set(f func(ctx context.Context, item string, id int64, newQuantity int64) (err error)) *ShopRepositoryMock {
	if mmUpdateInventory.defaultExpectation != nil {
		mmUpdateInventory.mock.t.Fatalf("Default expectation is already set for the ShopRepository.UpdateInventory method")
	}

	if len(mmUpdateInventory.expectations) > 0 {
		mmUpdateInventory.mock.t.Fatalf("Some expectations are already set for the ShopRepository.UpdateInventory method")
	}

	mmUpdateInventory.mock.funcUpdateInventory = f
	mmUpdateInventory.mock.funcUpdateInventoryOrigin = minimock.CallerInfo(1)
	return mmUpdateInventory.mock
}

// When sets expectation for the ShopRepository.UpdateInventory which will trigger the result defined by the following
// Then helper
func (mmUpdateInventory *mShopRepositoryMockUpdateInventory) When(ctx context.Context, item string, id int64, newQuantity int64) *ShopRepositoryMockUpdateInventoryExpectation {
	if mmUpdateInventory.mock.funcUpdateInventory != nil {
		mmUpdateInventory.mock.t.Fatalf("ShopRepositoryMock.UpdateInventory mock is already set by Set")
	}

	expectation := &ShopRepositoryMockUpdateInventoryExpectation{
		mock:               mmUpdateInventory.mock,
		params:             &ShopRepositoryMockUpdateInventoryParams{ctx, item, id, newQuantity},
		expectationOrigins: ShopRepositoryMockUpdateInventoryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateInventory.expectations = append(mmUpdateInventory.expectations, expectation)
	return expectation
}

// Then sets up ShopRepository.UpdateInventory return parameters for the expectation previously defined by the When method
func (e *ShopRepositoryMockUpdateInventoryExpectation) Then(err error) *ShopRepositoryMock {
	e.results = &ShopRepositoryMockUpdateInventoryResults{err}
	return e.mock
}

// Times sets number of times ShopRepository.UpdateInventory should be invoked
func (mmUpdateInventory *mShopRepositoryMockUpdateInventory) Times(n uint64) *mShopRepositoryMockUpdateInventory {
	if n == 0 {
		mmUpdateInventory.mock.t.Fatalf("Times of ShopRepositoryMock.UpdateInventory mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateInventory.expectedInvocations, n)
	mmUpdateInventory.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateInventory
}

func (mmUpdateInventory *mShopRepositoryMockUpdateInventory) invocationsDone() bool {
	if len(mmUpdateInventory.expectations) == 0 && mmUpdateInventory.defaultExpectation == nil && mmUpdateInventory.mock.funcUpdateInventory == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateInventory.mock.afterUpdateInventoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateInventory.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateInventory implements mm_repository.ShopRepository
func (mmUpdateInventory *ShopRepositoryMock) UpdateInventory(ctx context.Context, item string, id int64, newQuantity int64) (err error) {
	mm_atomic.AddUint64(&mmUpdateInventory.beforeUpdateInventoryCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateInventory.afterUpdateInventoryCounter, 1)

	mmUpdateInventory.t.Helper()

	if mmUpdateInventory.inspectFuncUpdateInventory != nil {
		mmUpdateInventory.inspectFuncUpdateInventory(ctx, item, id, newQuantity)
	}

	mm_params := ShopRepositoryMockUpdateInventoryParams{ctx, item, id, newQuantity}

	// Record call args
	mmUpdateInventory.UpdateInventoryMock.mutex.Lock()
	mmUpdateInventory.UpdateInventoryMock.callArgs = append(mmUpdateInventory.UpdateInventoryMock.callArgs, &mm_params)
	mmUpdateInventory.UpdateInventoryMock.mutex.Unlock()

	for _, e := range mmUpdateInventory.UpdateInventoryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateInventory.UpdateInventoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateInventory.UpdateInventoryMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateInventory.UpdateInventoryMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateInventory.UpdateInventoryMock.defaultExpectation.paramPtrs

		mm_got := ShopRepositoryMockUpdateInventoryParams{ctx, item, id, newQuantity}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateInventory.t.Errorf("ShopRepositoryMock.UpdateInventory got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateInventory.UpdateInventoryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmUpdateInventory.t.Errorf("ShopRepositoryMock.UpdateInventory got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateInventory.UpdateInventoryMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateInventory.t.Errorf("ShopRepositoryMock.UpdateInventory got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateInventory.UpdateInventoryMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.newQuantity != nil && !minimock.Equal(*mm_want_ptrs.newQuantity, mm_got.newQuantity) {
				mmUpdateInventory.t.Errorf("ShopRepositoryMock.UpdateInventory got unexpected parameter newQuantity, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateInventory.UpdateInventoryMock.defaultExpectation.expectationOrigins.originNewQuantity, *mm_want_ptrs.newQuantity, mm_got.newQuantity, minimock.Diff(*mm_want_ptrs.newQuantity, mm_got.newQuantity))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateInventory.t.Errorf("ShopRepositoryMock.UpdateInventory got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateInventory.UpdateInventoryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateInventory.UpdateInventoryMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateInventory.t.Fatal("No results are set for the ShopRepositoryMock.UpdateInventory")
		}
		return (*mm_results).err
	}
	if mmUpdateInventory.funcUpdateInventory != nil {
		return mmUpdateInventory.funcUpdateInventory(ctx, item, id, newQuantity)
	}
	mmUpdateInventory.t.Fatalf("Unexpected call to ShopRepositoryMock.UpdateInventory. %v %v %v %v", ctx, item, id, newQuantity)
	return
}

// UpdateInventoryAfterCounter returns a count of finished ShopRepositoryMock.UpdateInventory invocations
func (mmUpdateInventory *ShopRepositoryMock) UpdateInventoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateInventory.afterUpdateInventoryCounter)
}

// UpdateInventoryBeforeCounter returns a count of ShopRepositoryMock.UpdateInventory invocations
func (mmUpdateInventory *ShopRepositoryMock) UpdateInventoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateInventory.beforeUpdateInventoryCounter)
}

// Calls returns a list of arguments used in each call to ShopRepositoryMock.UpdateInventory.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateInventory *mShopRepositoryMockUpdateInventory) Calls() []*ShopRepositoryMockUpdateInventoryParams {
	mmUpdateInventory.mutex.RLock()

	argCopy := make([]*ShopRepositoryMockUpdateInventoryParams, len(mmUpdateInventory.callArgs))
	copy(argCopy, mmUpdateInventory.callArgs)

	mmUpdateInventory.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateInventoryDone returns true if the count of the UpdateInventory invocations corresponds
// the number of defined expectations
func (m *ShopRepositoryMock) MinimockUpdateInventoryDone() bool {
	if m.UpdateInventoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateInventoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateInventoryMock.invocationsDone()
}

// MinimockUpdateInventoryInspect logs each unmet expectation
func (m *ShopRepositoryMock) MinimockUpdateInventoryInspect() {
	for _, e := range m.UpdateInventoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ShopRepositoryMock.UpdateInventory at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateInventoryCounter := mm_atomic.LoadUint64(&m.afterUpdateInventoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateInventoryMock.defaultExpectation != nil && afterUpdateInventoryCounter < 1 {
		if m.UpdateInventoryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ShopRepositoryMock.UpdateInventory at\n%s", m.UpdateInventoryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ShopRepositoryMock.UpdateInventory at\n%s with params: %#v", m.UpdateInventoryMock.defaultExpectation.expectationOrigins.origin, *m.UpdateInventoryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateInventory != nil && afterUpdateInventoryCounter < 1 {
		m.t.Errorf("Expected call to ShopRepositoryMock.UpdateInventory at\n%s", m.funcUpdateInventoryOrigin)
	}

	if !m.UpdateInventoryMock.invocationsDone() && afterUpdateInventoryCounter > 0 {
		m.t.Errorf("Expected %d calls to ShopRepositoryMock.UpdateInventory at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateInventoryMock.expectedInvocations), m.UpdateInventoryMock.expectedInvocationsOrigin, afterUpdateInventoryCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ShopRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckInventoryInspect()

			m.MinimockCreateTransactionInspect()

			m.MinimockGetMerchPriceInspect()

			m.MinimockGetUserInventoryInspect()

			m.MinimockGetUserTransactionsInspect()

			m.MinimockInsertNewInventoryInspect()

			m.MinimockUpdateInventoryInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ShopRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ShopRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckInventoryDone() &&
		m.MinimockCreateTransactionDone() &&
		m.MinimockGetMerchPriceDone() &&
		m.MinimockGetUserInventoryDone() &&
		m.MinimockGetUserTransactionsDone() &&
		m.MinimockInsertNewInventoryDone() &&
		m.MinimockUpdateInventoryDone()
}
