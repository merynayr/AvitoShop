// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/merynayr/AvitoShop/internal/middleware.UserMiddleware -o user_middleware_minimock.go -n UserMiddlewareMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gin-gonic/gin"
	"github.com/gojuno/minimock/v3"
)

// UserMiddlewareMock implements mm_middleware.UserMiddleware
type UserMiddlewareMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddAccessTokenFromCookie          func() (h1 gin.HandlerFunc)
	funcAddAccessTokenFromCookieOrigin    string
	inspectFuncAddAccessTokenFromCookie   func()
	afterAddAccessTokenFromCookieCounter  uint64
	beforeAddAccessTokenFromCookieCounter uint64
	AddAccessTokenFromCookieMock          mUserMiddlewareMockAddAccessTokenFromCookie

	funcCheck          func() (h1 gin.HandlerFunc)
	funcCheckOrigin    string
	inspectFuncCheck   func()
	afterCheckCounter  uint64
	beforeCheckCounter uint64
	CheckMock          mUserMiddlewareMockCheck

	funcExtractUserID          func() (h1 gin.HandlerFunc)
	funcExtractUserIDOrigin    string
	inspectFuncExtractUserID   func()
	afterExtractUserIDCounter  uint64
	beforeExtractUserIDCounter uint64
	ExtractUserIDMock          mUserMiddlewareMockExtractUserID
}

// NewUserMiddlewareMock returns a mock for mm_middleware.UserMiddleware
func NewUserMiddlewareMock(t minimock.Tester) *UserMiddlewareMock {
	m := &UserMiddlewareMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddAccessTokenFromCookieMock = mUserMiddlewareMockAddAccessTokenFromCookie{mock: m}

	m.CheckMock = mUserMiddlewareMockCheck{mock: m}

	m.ExtractUserIDMock = mUserMiddlewareMockExtractUserID{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserMiddlewareMockAddAccessTokenFromCookie struct {
	optional           bool
	mock               *UserMiddlewareMock
	defaultExpectation *UserMiddlewareMockAddAccessTokenFromCookieExpectation
	expectations       []*UserMiddlewareMockAddAccessTokenFromCookieExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMiddlewareMockAddAccessTokenFromCookieExpectation specifies expectation struct of the UserMiddleware.AddAccessTokenFromCookie
type UserMiddlewareMockAddAccessTokenFromCookieExpectation struct {
	mock *UserMiddlewareMock

	results      *UserMiddlewareMockAddAccessTokenFromCookieResults
	returnOrigin string
	Counter      uint64
}

// UserMiddlewareMockAddAccessTokenFromCookieResults contains results of the UserMiddleware.AddAccessTokenFromCookie
type UserMiddlewareMockAddAccessTokenFromCookieResults struct {
	h1 gin.HandlerFunc
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddAccessTokenFromCookie *mUserMiddlewareMockAddAccessTokenFromCookie) Optional() *mUserMiddlewareMockAddAccessTokenFromCookie {
	mmAddAccessTokenFromCookie.optional = true
	return mmAddAccessTokenFromCookie
}

// Expect sets up expected params for UserMiddleware.AddAccessTokenFromCookie
func (mmAddAccessTokenFromCookie *mUserMiddlewareMockAddAccessTokenFromCookie) Expect() *mUserMiddlewareMockAddAccessTokenFromCookie {
	if mmAddAccessTokenFromCookie.mock.funcAddAccessTokenFromCookie != nil {
		mmAddAccessTokenFromCookie.mock.t.Fatalf("UserMiddlewareMock.AddAccessTokenFromCookie mock is already set by Set")
	}

	if mmAddAccessTokenFromCookie.defaultExpectation == nil {
		mmAddAccessTokenFromCookie.defaultExpectation = &UserMiddlewareMockAddAccessTokenFromCookieExpectation{}
	}

	return mmAddAccessTokenFromCookie
}

// Inspect accepts an inspector function that has same arguments as the UserMiddleware.AddAccessTokenFromCookie
func (mmAddAccessTokenFromCookie *mUserMiddlewareMockAddAccessTokenFromCookie) Inspect(f func()) *mUserMiddlewareMockAddAccessTokenFromCookie {
	if mmAddAccessTokenFromCookie.mock.inspectFuncAddAccessTokenFromCookie != nil {
		mmAddAccessTokenFromCookie.mock.t.Fatalf("Inspect function is already set for UserMiddlewareMock.AddAccessTokenFromCookie")
	}

	mmAddAccessTokenFromCookie.mock.inspectFuncAddAccessTokenFromCookie = f

	return mmAddAccessTokenFromCookie
}

// Return sets up results that will be returned by UserMiddleware.AddAccessTokenFromCookie
func (mmAddAccessTokenFromCookie *mUserMiddlewareMockAddAccessTokenFromCookie) Return(h1 gin.HandlerFunc) *UserMiddlewareMock {
	if mmAddAccessTokenFromCookie.mock.funcAddAccessTokenFromCookie != nil {
		mmAddAccessTokenFromCookie.mock.t.Fatalf("UserMiddlewareMock.AddAccessTokenFromCookie mock is already set by Set")
	}

	if mmAddAccessTokenFromCookie.defaultExpectation == nil {
		mmAddAccessTokenFromCookie.defaultExpectation = &UserMiddlewareMockAddAccessTokenFromCookieExpectation{mock: mmAddAccessTokenFromCookie.mock}
	}
	mmAddAccessTokenFromCookie.defaultExpectation.results = &UserMiddlewareMockAddAccessTokenFromCookieResults{h1}
	mmAddAccessTokenFromCookie.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddAccessTokenFromCookie.mock
}

// Set uses given function f to mock the UserMiddleware.AddAccessTokenFromCookie method
func (mmAddAccessTokenFromCookie *mUserMiddlewareMockAddAccessTokenFromCookie) Set(f func() (h1 gin.HandlerFunc)) *UserMiddlewareMock {
	if mmAddAccessTokenFromCookie.defaultExpectation != nil {
		mmAddAccessTokenFromCookie.mock.t.Fatalf("Default expectation is already set for the UserMiddleware.AddAccessTokenFromCookie method")
	}

	if len(mmAddAccessTokenFromCookie.expectations) > 0 {
		mmAddAccessTokenFromCookie.mock.t.Fatalf("Some expectations are already set for the UserMiddleware.AddAccessTokenFromCookie method")
	}

	mmAddAccessTokenFromCookie.mock.funcAddAccessTokenFromCookie = f
	mmAddAccessTokenFromCookie.mock.funcAddAccessTokenFromCookieOrigin = minimock.CallerInfo(1)
	return mmAddAccessTokenFromCookie.mock
}

// Times sets number of times UserMiddleware.AddAccessTokenFromCookie should be invoked
func (mmAddAccessTokenFromCookie *mUserMiddlewareMockAddAccessTokenFromCookie) Times(n uint64) *mUserMiddlewareMockAddAccessTokenFromCookie {
	if n == 0 {
		mmAddAccessTokenFromCookie.mock.t.Fatalf("Times of UserMiddlewareMock.AddAccessTokenFromCookie mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddAccessTokenFromCookie.expectedInvocations, n)
	mmAddAccessTokenFromCookie.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddAccessTokenFromCookie
}

func (mmAddAccessTokenFromCookie *mUserMiddlewareMockAddAccessTokenFromCookie) invocationsDone() bool {
	if len(mmAddAccessTokenFromCookie.expectations) == 0 && mmAddAccessTokenFromCookie.defaultExpectation == nil && mmAddAccessTokenFromCookie.mock.funcAddAccessTokenFromCookie == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddAccessTokenFromCookie.mock.afterAddAccessTokenFromCookieCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddAccessTokenFromCookie.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddAccessTokenFromCookie implements mm_middleware.UserMiddleware
func (mmAddAccessTokenFromCookie *UserMiddlewareMock) AddAccessTokenFromCookie() (h1 gin.HandlerFunc) {
	mm_atomic.AddUint64(&mmAddAccessTokenFromCookie.beforeAddAccessTokenFromCookieCounter, 1)
	defer mm_atomic.AddUint64(&mmAddAccessTokenFromCookie.afterAddAccessTokenFromCookieCounter, 1)

	mmAddAccessTokenFromCookie.t.Helper()

	if mmAddAccessTokenFromCookie.inspectFuncAddAccessTokenFromCookie != nil {
		mmAddAccessTokenFromCookie.inspectFuncAddAccessTokenFromCookie()
	}

	if mmAddAccessTokenFromCookie.AddAccessTokenFromCookieMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddAccessTokenFromCookie.AddAccessTokenFromCookieMock.defaultExpectation.Counter, 1)

		mm_results := mmAddAccessTokenFromCookie.AddAccessTokenFromCookieMock.defaultExpectation.results
		if mm_results == nil {
			mmAddAccessTokenFromCookie.t.Fatal("No results are set for the UserMiddlewareMock.AddAccessTokenFromCookie")
		}
		return (*mm_results).h1
	}
	if mmAddAccessTokenFromCookie.funcAddAccessTokenFromCookie != nil {
		return mmAddAccessTokenFromCookie.funcAddAccessTokenFromCookie()
	}
	mmAddAccessTokenFromCookie.t.Fatalf("Unexpected call to UserMiddlewareMock.AddAccessTokenFromCookie.")
	return
}

// AddAccessTokenFromCookieAfterCounter returns a count of finished UserMiddlewareMock.AddAccessTokenFromCookie invocations
func (mmAddAccessTokenFromCookie *UserMiddlewareMock) AddAccessTokenFromCookieAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddAccessTokenFromCookie.afterAddAccessTokenFromCookieCounter)
}

// AddAccessTokenFromCookieBeforeCounter returns a count of UserMiddlewareMock.AddAccessTokenFromCookie invocations
func (mmAddAccessTokenFromCookie *UserMiddlewareMock) AddAccessTokenFromCookieBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddAccessTokenFromCookie.beforeAddAccessTokenFromCookieCounter)
}

// MinimockAddAccessTokenFromCookieDone returns true if the count of the AddAccessTokenFromCookie invocations corresponds
// the number of defined expectations
func (m *UserMiddlewareMock) MinimockAddAccessTokenFromCookieDone() bool {
	if m.AddAccessTokenFromCookieMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddAccessTokenFromCookieMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddAccessTokenFromCookieMock.invocationsDone()
}

// MinimockAddAccessTokenFromCookieInspect logs each unmet expectation
func (m *UserMiddlewareMock) MinimockAddAccessTokenFromCookieInspect() {
	for _, e := range m.AddAccessTokenFromCookieMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to UserMiddlewareMock.AddAccessTokenFromCookie")
		}
	}

	afterAddAccessTokenFromCookieCounter := mm_atomic.LoadUint64(&m.afterAddAccessTokenFromCookieCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddAccessTokenFromCookieMock.defaultExpectation != nil && afterAddAccessTokenFromCookieCounter < 1 {
		m.t.Errorf("Expected call to UserMiddlewareMock.AddAccessTokenFromCookie at\n%s", m.AddAccessTokenFromCookieMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddAccessTokenFromCookie != nil && afterAddAccessTokenFromCookieCounter < 1 {
		m.t.Errorf("Expected call to UserMiddlewareMock.AddAccessTokenFromCookie at\n%s", m.funcAddAccessTokenFromCookieOrigin)
	}

	if !m.AddAccessTokenFromCookieMock.invocationsDone() && afterAddAccessTokenFromCookieCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMiddlewareMock.AddAccessTokenFromCookie at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddAccessTokenFromCookieMock.expectedInvocations), m.AddAccessTokenFromCookieMock.expectedInvocationsOrigin, afterAddAccessTokenFromCookieCounter)
	}
}

type mUserMiddlewareMockCheck struct {
	optional           bool
	mock               *UserMiddlewareMock
	defaultExpectation *UserMiddlewareMockCheckExpectation
	expectations       []*UserMiddlewareMockCheckExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMiddlewareMockCheckExpectation specifies expectation struct of the UserMiddleware.Check
type UserMiddlewareMockCheckExpectation struct {
	mock *UserMiddlewareMock

	results      *UserMiddlewareMockCheckResults
	returnOrigin string
	Counter      uint64
}

// UserMiddlewareMockCheckResults contains results of the UserMiddleware.Check
type UserMiddlewareMockCheckResults struct {
	h1 gin.HandlerFunc
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheck *mUserMiddlewareMockCheck) Optional() *mUserMiddlewareMockCheck {
	mmCheck.optional = true
	return mmCheck
}

// Expect sets up expected params for UserMiddleware.Check
func (mmCheck *mUserMiddlewareMockCheck) Expect() *mUserMiddlewareMockCheck {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("UserMiddlewareMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &UserMiddlewareMockCheckExpectation{}
	}

	return mmCheck
}

// Inspect accepts an inspector function that has same arguments as the UserMiddleware.Check
func (mmCheck *mUserMiddlewareMockCheck) Inspect(f func()) *mUserMiddlewareMockCheck {
	if mmCheck.mock.inspectFuncCheck != nil {
		mmCheck.mock.t.Fatalf("Inspect function is already set for UserMiddlewareMock.Check")
	}

	mmCheck.mock.inspectFuncCheck = f

	return mmCheck
}

// Return sets up results that will be returned by UserMiddleware.Check
func (mmCheck *mUserMiddlewareMockCheck) Return(h1 gin.HandlerFunc) *UserMiddlewareMock {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("UserMiddlewareMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &UserMiddlewareMockCheckExpectation{mock: mmCheck.mock}
	}
	mmCheck.defaultExpectation.results = &UserMiddlewareMockCheckResults{h1}
	mmCheck.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheck.mock
}

// Set uses given function f to mock the UserMiddleware.Check method
func (mmCheck *mUserMiddlewareMockCheck) Set(f func() (h1 gin.HandlerFunc)) *UserMiddlewareMock {
	if mmCheck.defaultExpectation != nil {
		mmCheck.mock.t.Fatalf("Default expectation is already set for the UserMiddleware.Check method")
	}

	if len(mmCheck.expectations) > 0 {
		mmCheck.mock.t.Fatalf("Some expectations are already set for the UserMiddleware.Check method")
	}

	mmCheck.mock.funcCheck = f
	mmCheck.mock.funcCheckOrigin = minimock.CallerInfo(1)
	return mmCheck.mock
}

// Times sets number of times UserMiddleware.Check should be invoked
func (mmCheck *mUserMiddlewareMockCheck) Times(n uint64) *mUserMiddlewareMockCheck {
	if n == 0 {
		mmCheck.mock.t.Fatalf("Times of UserMiddlewareMock.Check mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheck.expectedInvocations, n)
	mmCheck.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheck
}

func (mmCheck *mUserMiddlewareMockCheck) invocationsDone() bool {
	if len(mmCheck.expectations) == 0 && mmCheck.defaultExpectation == nil && mmCheck.mock.funcCheck == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheck.mock.afterCheckCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheck.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Check implements mm_middleware.UserMiddleware
func (mmCheck *UserMiddlewareMock) Check() (h1 gin.HandlerFunc) {
	mm_atomic.AddUint64(&mmCheck.beforeCheckCounter, 1)
	defer mm_atomic.AddUint64(&mmCheck.afterCheckCounter, 1)

	mmCheck.t.Helper()

	if mmCheck.inspectFuncCheck != nil {
		mmCheck.inspectFuncCheck()
	}

	if mmCheck.CheckMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheck.CheckMock.defaultExpectation.Counter, 1)

		mm_results := mmCheck.CheckMock.defaultExpectation.results
		if mm_results == nil {
			mmCheck.t.Fatal("No results are set for the UserMiddlewareMock.Check")
		}
		return (*mm_results).h1
	}
	if mmCheck.funcCheck != nil {
		return mmCheck.funcCheck()
	}
	mmCheck.t.Fatalf("Unexpected call to UserMiddlewareMock.Check.")
	return
}

// CheckAfterCounter returns a count of finished UserMiddlewareMock.Check invocations
func (mmCheck *UserMiddlewareMock) CheckAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheck.afterCheckCounter)
}

// CheckBeforeCounter returns a count of UserMiddlewareMock.Check invocations
func (mmCheck *UserMiddlewareMock) CheckBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheck.beforeCheckCounter)
}

// MinimockCheckDone returns true if the count of the Check invocations corresponds
// the number of defined expectations
func (m *UserMiddlewareMock) MinimockCheckDone() bool {
	if m.CheckMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckMock.invocationsDone()
}

// MinimockCheckInspect logs each unmet expectation
func (m *UserMiddlewareMock) MinimockCheckInspect() {
	for _, e := range m.CheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to UserMiddlewareMock.Check")
		}
	}

	afterCheckCounter := mm_atomic.LoadUint64(&m.afterCheckCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckMock.defaultExpectation != nil && afterCheckCounter < 1 {
		m.t.Errorf("Expected call to UserMiddlewareMock.Check at\n%s", m.CheckMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheck != nil && afterCheckCounter < 1 {
		m.t.Errorf("Expected call to UserMiddlewareMock.Check at\n%s", m.funcCheckOrigin)
	}

	if !m.CheckMock.invocationsDone() && afterCheckCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMiddlewareMock.Check at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckMock.expectedInvocations), m.CheckMock.expectedInvocationsOrigin, afterCheckCounter)
	}
}

type mUserMiddlewareMockExtractUserID struct {
	optional           bool
	mock               *UserMiddlewareMock
	defaultExpectation *UserMiddlewareMockExtractUserIDExpectation
	expectations       []*UserMiddlewareMockExtractUserIDExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMiddlewareMockExtractUserIDExpectation specifies expectation struct of the UserMiddleware.ExtractUserID
type UserMiddlewareMockExtractUserIDExpectation struct {
	mock *UserMiddlewareMock

	results      *UserMiddlewareMockExtractUserIDResults
	returnOrigin string
	Counter      uint64
}

// UserMiddlewareMockExtractUserIDResults contains results of the UserMiddleware.ExtractUserID
type UserMiddlewareMockExtractUserIDResults struct {
	h1 gin.HandlerFunc
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExtractUserID *mUserMiddlewareMockExtractUserID) Optional() *mUserMiddlewareMockExtractUserID {
	mmExtractUserID.optional = true
	return mmExtractUserID
}

// Expect sets up expected params for UserMiddleware.ExtractUserID
func (mmExtractUserID *mUserMiddlewareMockExtractUserID) Expect() *mUserMiddlewareMockExtractUserID {
	if mmExtractUserID.mock.funcExtractUserID != nil {
		mmExtractUserID.mock.t.Fatalf("UserMiddlewareMock.ExtractUserID mock is already set by Set")
	}

	if mmExtractUserID.defaultExpectation == nil {
		mmExtractUserID.defaultExpectation = &UserMiddlewareMockExtractUserIDExpectation{}
	}

	return mmExtractUserID
}

// Inspect accepts an inspector function that has same arguments as the UserMiddleware.ExtractUserID
func (mmExtractUserID *mUserMiddlewareMockExtractUserID) Inspect(f func()) *mUserMiddlewareMockExtractUserID {
	if mmExtractUserID.mock.inspectFuncExtractUserID != nil {
		mmExtractUserID.mock.t.Fatalf("Inspect function is already set for UserMiddlewareMock.ExtractUserID")
	}

	mmExtractUserID.mock.inspectFuncExtractUserID = f

	return mmExtractUserID
}

// Return sets up results that will be returned by UserMiddleware.ExtractUserID
func (mmExtractUserID *mUserMiddlewareMockExtractUserID) Return(h1 gin.HandlerFunc) *UserMiddlewareMock {
	if mmExtractUserID.mock.funcExtractUserID != nil {
		mmExtractUserID.mock.t.Fatalf("UserMiddlewareMock.ExtractUserID mock is already set by Set")
	}

	if mmExtractUserID.defaultExpectation == nil {
		mmExtractUserID.defaultExpectation = &UserMiddlewareMockExtractUserIDExpectation{mock: mmExtractUserID.mock}
	}
	mmExtractUserID.defaultExpectation.results = &UserMiddlewareMockExtractUserIDResults{h1}
	mmExtractUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExtractUserID.mock
}

// Set uses given function f to mock the UserMiddleware.ExtractUserID method
func (mmExtractUserID *mUserMiddlewareMockExtractUserID) Set(f func() (h1 gin.HandlerFunc)) *UserMiddlewareMock {
	if mmExtractUserID.defaultExpectation != nil {
		mmExtractUserID.mock.t.Fatalf("Default expectation is already set for the UserMiddleware.ExtractUserID method")
	}

	if len(mmExtractUserID.expectations) > 0 {
		mmExtractUserID.mock.t.Fatalf("Some expectations are already set for the UserMiddleware.ExtractUserID method")
	}

	mmExtractUserID.mock.funcExtractUserID = f
	mmExtractUserID.mock.funcExtractUserIDOrigin = minimock.CallerInfo(1)
	return mmExtractUserID.mock
}

// Times sets number of times UserMiddleware.ExtractUserID should be invoked
func (mmExtractUserID *mUserMiddlewareMockExtractUserID) Times(n uint64) *mUserMiddlewareMockExtractUserID {
	if n == 0 {
		mmExtractUserID.mock.t.Fatalf("Times of UserMiddlewareMock.ExtractUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExtractUserID.expectedInvocations, n)
	mmExtractUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExtractUserID
}

func (mmExtractUserID *mUserMiddlewareMockExtractUserID) invocationsDone() bool {
	if len(mmExtractUserID.expectations) == 0 && mmExtractUserID.defaultExpectation == nil && mmExtractUserID.mock.funcExtractUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExtractUserID.mock.afterExtractUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExtractUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ExtractUserID implements mm_middleware.UserMiddleware
func (mmExtractUserID *UserMiddlewareMock) ExtractUserID() (h1 gin.HandlerFunc) {
	mm_atomic.AddUint64(&mmExtractUserID.beforeExtractUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmExtractUserID.afterExtractUserIDCounter, 1)

	mmExtractUserID.t.Helper()

	if mmExtractUserID.inspectFuncExtractUserID != nil {
		mmExtractUserID.inspectFuncExtractUserID()
	}

	if mmExtractUserID.ExtractUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExtractUserID.ExtractUserIDMock.defaultExpectation.Counter, 1)

		mm_results := mmExtractUserID.ExtractUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmExtractUserID.t.Fatal("No results are set for the UserMiddlewareMock.ExtractUserID")
		}
		return (*mm_results).h1
	}
	if mmExtractUserID.funcExtractUserID != nil {
		return mmExtractUserID.funcExtractUserID()
	}
	mmExtractUserID.t.Fatalf("Unexpected call to UserMiddlewareMock.ExtractUserID.")
	return
}

// ExtractUserIDAfterCounter returns a count of finished UserMiddlewareMock.ExtractUserID invocations
func (mmExtractUserID *UserMiddlewareMock) ExtractUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExtractUserID.afterExtractUserIDCounter)
}

// ExtractUserIDBeforeCounter returns a count of UserMiddlewareMock.ExtractUserID invocations
func (mmExtractUserID *UserMiddlewareMock) ExtractUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExtractUserID.beforeExtractUserIDCounter)
}

// MinimockExtractUserIDDone returns true if the count of the ExtractUserID invocations corresponds
// the number of defined expectations
func (m *UserMiddlewareMock) MinimockExtractUserIDDone() bool {
	if m.ExtractUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExtractUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExtractUserIDMock.invocationsDone()
}

// MinimockExtractUserIDInspect logs each unmet expectation
func (m *UserMiddlewareMock) MinimockExtractUserIDInspect() {
	for _, e := range m.ExtractUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to UserMiddlewareMock.ExtractUserID")
		}
	}

	afterExtractUserIDCounter := mm_atomic.LoadUint64(&m.afterExtractUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExtractUserIDMock.defaultExpectation != nil && afterExtractUserIDCounter < 1 {
		m.t.Errorf("Expected call to UserMiddlewareMock.ExtractUserID at\n%s", m.ExtractUserIDMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExtractUserID != nil && afterExtractUserIDCounter < 1 {
		m.t.Errorf("Expected call to UserMiddlewareMock.ExtractUserID at\n%s", m.funcExtractUserIDOrigin)
	}

	if !m.ExtractUserIDMock.invocationsDone() && afterExtractUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMiddlewareMock.ExtractUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExtractUserIDMock.expectedInvocations), m.ExtractUserIDMock.expectedInvocationsOrigin, afterExtractUserIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserMiddlewareMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddAccessTokenFromCookieInspect()

			m.MinimockCheckInspect()

			m.MinimockExtractUserIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserMiddlewareMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserMiddlewareMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddAccessTokenFromCookieDone() &&
		m.MinimockCheckDone() &&
		m.MinimockExtractUserIDDone()
}
